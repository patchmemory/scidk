    <!-- Integrations Section -->
    <section id="integrations-section" class="settings-section">
  <h1>Integrations</h1>
  <p class="small">Configure integration mappings, API endpoints, and matching options.</p>

  <h2 style="margin-top: 1.5rem;">API Endpoint Mappings</h2>
  <p class="small">Define API endpoints that map to Label types in SciDK.</p>

  <!-- Add Endpoint Form -->
  <div style="margin-bottom: 1.5rem; padding: 1rem; background: #f9f9f9; border-radius: 4px;">
    <h3 style="margin-top: 0;">Add New Endpoint</h3>
    <div class="form-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
      <div>
        <label for="api-endpoint-name">Name:</label>
        <input type="text" id="api-endpoint-name" class="form-control" placeholder="Users API" data-testid="api-endpoint-name">
      </div>
      <div>
        <label for="api-endpoint-url">URL:</label>
        <input type="text" id="api-endpoint-url" class="form-control" placeholder="https://api.example.com/users" data-testid="api-endpoint-url">
      </div>
      <div>
        <label for="api-endpoint-auth-method">Auth Method:</label>
        <select id="api-endpoint-auth-method" class="form-control" data-testid="api-endpoint-auth-method">
          <option value="none">None</option>
          <option value="bearer">Bearer Token</option>
          <option value="api_key">API Key</option>
        </select>
      </div>
      <div>
        <label for="api-endpoint-auth-value">Auth Value:</label>
        <input type="password" id="api-endpoint-auth-value" class="form-control" placeholder="Optional" data-testid="api-endpoint-auth-value">
      </div>
      <div>
        <label for="api-endpoint-json-path">JSONPath (optional):</label>
        <input type="text" id="api-endpoint-json-path" class="form-control" placeholder="$.data[*]" data-testid="api-endpoint-json-path">
      </div>
      <div>
        <label for="api-endpoint-target-label">Maps to Label (optional):</label>
        <select id="api-endpoint-target-label" class="form-control" data-testid="api-endpoint-target-label">
          <option value="">-- Select Label --</option>
        </select>
      </div>
    </div>
    <div style="display: flex; gap: 0.5rem;">
      <button id="btn-test-api-endpoint" class="btn btn-sm btn-outline-primary" data-testid="btn-test-api-endpoint">Test Connection</button>
      <button id="btn-save-api-endpoint" class="btn btn-sm btn-primary" data-testid="btn-save-api-endpoint">Save Endpoint</button>
      <button id="btn-cancel-api-endpoint" class="btn btn-sm btn-outline-secondary" style="display: none;" data-testid="btn-cancel-api-endpoint">Cancel</button>
    </div>
    <div id="api-endpoint-message" class="small" style="margin-top: 0.5rem; color: var(--accent);"></div>
  </div>

  <!-- Endpoints List -->
  <h3>Registered Endpoints</h3>
  <div id="api-endpoints-list">
    <p class="small" style="color: #999;"><em>No endpoints registered yet</em></p>
  </div>

  <!-- Plugin-Registered Endpoints -->
  <h3 style="margin-top: 1.5rem;">Plugin Endpoints</h3>
  <p class="small">Endpoints registered by installed plugins. These cannot be edited manually.</p>
  <div id="plugin-endpoints-list">
    <p class="small" style="color: #999;"><em>No plugin endpoints registered</em></p>
  </div>

  <h2 style="margin-top: 1.5rem;">Table Format Registry</h2>
  <p class="small">Manage table formats for importing CSV, TSV, Excel, and Parquet files as link sources.</p>

  <!-- Add Format Form -->
  <div style="margin-bottom: 1.5rem; padding: 1rem; background: #f9f9f9; border-radius: 4px;">
    <h3 style="margin-top: 0;">Add Custom Format</h3>
    <div class="form-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-bottom: 0.75rem;">
      <div>
        <label for="table-format-name">Name:</label>
        <input type="text" id="table-format-name" class="form-control" placeholder="My CSV Format" data-testid="table-format-name">
      </div>
      <div>
        <label for="table-format-file-type">File Type:</label>
        <select id="table-format-file-type" class="form-control" data-testid="table-format-file-type">
          <option value="csv">CSV</option>
          <option value="tsv">TSV</option>
          <option value="excel">Excel</option>
          <option value="parquet">Parquet</option>
        </select>
      </div>
      <div>
        <label for="table-format-delimiter">Delimiter:</label>
        <input type="text" id="table-format-delimiter" class="form-control" placeholder="," maxlength="1" data-testid="table-format-delimiter">
      </div>
      <div>
        <label for="table-format-encoding">Encoding:</label>
        <select id="table-format-encoding" class="form-control" data-testid="table-format-encoding">
          <option value="utf-8">UTF-8</option>
          <option value="latin-1">Latin-1</option>
          <option value="utf-16">UTF-16</option>
        </select>
      </div>
      <div>
        <label for="table-format-target-label">Target Label (optional):</label>
        <select id="table-format-target-label" class="form-control" data-testid="table-format-target-label">
          <option value="">-- Select Label --</option>
        </select>
      </div>
      <div style="display: flex; align-items: end; gap: 0.5rem;">
        <div class="form-check">
          <input id="table-format-has-header" class="form-check-input" type="checkbox" checked data-testid="table-format-has-header">
          <label for="table-format-has-header" class="form-check-label small">Has Header Row</label>
        </div>
      </div>
    </div>
    <div>
      <label for="table-format-description">Description (optional):</label>
      <input type="text" id="table-format-description" class="form-control" placeholder="Custom format for..." data-testid="table-format-description">
    </div>
    <div style="display: flex; gap: 0.5rem; margin-top: 0.75rem;">
      <button id="btn-save-table-format" class="btn btn-sm btn-primary" data-testid="btn-save-table-format">Save Format</button>
      <button id="btn-cancel-table-format" class="btn btn-sm btn-outline-secondary" style="display: none;" data-testid="btn-cancel-table-format">Cancel</button>
      <label class="btn btn-sm btn-outline-secondary" for="table-format-upload-sample">
        <input type="file" id="table-format-upload-sample" style="display: none;" accept=".csv,.tsv,.txt,.xlsx,.xls,.parquet" data-testid="table-format-upload-sample">
        Upload Sample & Detect
      </label>
    </div>
    <div id="table-format-message" class="small" style="margin-top: 0.5rem; color: var(--accent);"></div>

    <!-- Preview Section -->
    <div id="table-format-preview" style="display: none; margin-top: 1rem; padding: 1rem; background: #fff; border: 1px solid #ddd; border-radius: 4px;">
      <h4>Data Preview</h4>
      <div id="table-format-preview-content"></div>
    </div>
  </div>

  <!-- Formats List -->
  <h3>Registered Formats</h3>
  <div id="table-formats-list">
    <p class="small" style="color: #999;"><em>Loading formats...</em></p>
  </div>

  <h2 style="margin-top: 1.5rem;">Fuzzy Matching Options</h2>
  <p class="small">Configure fuzzy matching algorithms for entity resolution in link creation.</p>

  <!-- Fuzzy Matching Settings Form -->
  <div style="margin-bottom: 1.5rem; padding: 1rem; background: #f9f9f9; border-radius: 4px; max-width: 800px;">
    <h3 style="margin-top: 0;">Global Fuzzy Matching Settings</h3>

    <!-- Primary Settings -->
    <div class="row g-2" style="margin-bottom: 1rem;">
      <div class="col-12 col-md-6">
        <label class="form-label small" for="fuzzy-algorithm">Matching Algorithm:</label>
        <select id="fuzzy-algorithm" class="form-control form-control-sm" data-testid="fuzzy-algorithm">
          <option value="exact">Exact Match</option>
          <option value="levenshtein">Levenshtein Distance</option>
          <option value="jaro_winkler">Jaro-Winkler Distance</option>
          <option value="phonetic">Phonetic (Soundex/Metaphone)</option>
        </select>
        <div class="small text-muted">Levenshtein: general fuzzy matching | Jaro-Winkler: names | Phonetic: sound-alike</div>
      </div>
      <div class="col-12 col-md-6">
        <label class="form-label small" for="fuzzy-threshold">Similarity Threshold: <span id="fuzzy-threshold-value">80</span>%</label>
        <input id="fuzzy-threshold" type="range" class="form-range" min="0" max="100" value="80" data-testid="fuzzy-threshold">
        <div class="small text-muted">Minimum similarity score (0-100%) to consider a match</div>
      </div>
    </div>

    <!-- Normalization Options -->
    <div class="row g-2" style="margin-bottom: 1rem;">
      <div class="col-12 col-md-4">
        <div class="form-check">
          <input id="fuzzy-case-sensitive" class="form-check-input" type="checkbox" data-testid="fuzzy-case-sensitive">
          <label class="form-check-label small" for="fuzzy-case-sensitive">Case Sensitive</label>
        </div>
      </div>
      <div class="col-12 col-md-4">
        <div class="form-check">
          <input id="fuzzy-normalize-whitespace" class="form-check-input" type="checkbox" checked data-testid="fuzzy-normalize-whitespace">
          <label class="form-check-label small" for="fuzzy-normalize-whitespace">Normalize Whitespace</label>
        </div>
      </div>
      <div class="col-12 col-md-4">
        <div class="form-check">
          <input id="fuzzy-strip-punctuation" class="form-check-input" type="checkbox" checked data-testid="fuzzy-strip-punctuation">
          <label class="form-check-label small" for="fuzzy-strip-punctuation">Strip Punctuation</label>
        </div>
      </div>
    </div>

    <!-- Phonetic Settings (shown when algorithm is phonetic) -->
    <div id="fuzzy-phonetic-settings" style="display: none; margin-bottom: 1rem;">
      <div class="row g-2">
        <div class="col-12 col-md-6">
          <div class="form-check">
            <input id="fuzzy-phonetic-enabled" class="form-check-input" type="checkbox" data-testid="fuzzy-phonetic-enabled">
            <label class="form-check-label small" for="fuzzy-phonetic-enabled">Enable Phonetic Matching</label>
          </div>
        </div>
        <div class="col-12 col-md-6">
          <label class="form-label small" for="fuzzy-phonetic-algorithm">Phonetic Algorithm:</label>
          <select id="fuzzy-phonetic-algorithm" class="form-control form-control-sm" data-testid="fuzzy-phonetic-algorithm">
            <option value="soundex">Soundex</option>
            <option value="metaphone">Metaphone (Better)</option>
            <option value="double_metaphone">Double Metaphone</option>
          </select>
        </div>
      </div>
    </div>

    <!-- Advanced Settings (Collapsible) -->
    <details style="margin-bottom: 1rem;">
      <summary class="small" style="cursor: pointer;">Advanced Options</summary>
      <div class="row g-2" style="margin-top: 0.5rem;">
        <div class="col-12 col-md-4">
          <label class="form-label small" for="fuzzy-min-length">Min String Length:</label>
          <input id="fuzzy-min-length" type="number" class="form-control form-control-sm" min="1" max="10" value="3" data-testid="fuzzy-min-length">
        </div>
        <div class="col-12 col-md-4">
          <label class="form-label small" for="fuzzy-max-comparisons">Max Comparisons:</label>
          <input id="fuzzy-max-comparisons" type="number" class="form-control form-control-sm" min="100" max="100000" step="100" value="10000" data-testid="fuzzy-max-comparisons">
        </div>
        <div class="col-12 col-md-4" style="display: flex; align-items: end;">
          <div class="form-check">
            <input id="fuzzy-show-confidence" class="form-check-input" type="checkbox" checked data-testid="fuzzy-show-confidence">
            <label class="form-check-label small" for="fuzzy-show-confidence">Show Confidence Scores</label>
          </div>
        </div>
      </div>
    </details>

    <!-- Action Buttons -->
    <div style="display: flex; gap: 0.5rem;">
      <button id="btn-save-fuzzy-settings" class="btn btn-sm btn-primary" data-testid="btn-save-fuzzy-settings">Save Settings</button>
      <button id="btn-reset-fuzzy-settings" class="btn btn-sm btn-outline-secondary" data-testid="btn-reset-fuzzy-settings">Reset to Defaults</button>
    </div>
    <div id="fuzzy-settings-message" class="small" style="margin-top: 0.5rem; color: var(--accent);"></div>
  </div>

  <!-- Architecture Info -->
  <div style="padding: 1rem; background: #f0f8ff; border-left: 3px solid #19c37d; margin-bottom: 1rem; max-width: 800px;">
    <h4 class="small" style="margin-top: 0;">Hybrid Matching Architecture</h4>
    <p class="small" style="margin-bottom: 0.5rem;">
      <strong>Phase 1 (Client-Side):</strong> Pre-import matching using rapidfuzz - match external API/CSV data before pushing to Neo4j.
    </p>
    <p class="small" style="margin: 0;">
      <strong>Phase 2 (Server-Side):</strong> Post-import matching using Neo4j APOC functions - ultra-fast in-database entity resolution for existing nodes.
    </p>
  </div>
    </section>

<script>
  function initAPIEndpoints() {
    let editingEndpointId = null;
    const nameInput = document.getElementById('api-endpoint-name');
    const urlInput = document.getElementById('api-endpoint-url');
    const authMethodSelect = document.getElementById('api-endpoint-auth-method');
    const authValueInput = document.getElementById('api-endpoint-auth-value');
    const jsonPathInput = document.getElementById('api-endpoint-json-path');
    const targetLabelSelect = document.getElementById('api-endpoint-target-label');
    const btnTest = document.getElementById('btn-test-api-endpoint');
    const btnSave = document.getElementById('btn-save-api-endpoint');
    const btnCancel = document.getElementById('btn-cancel-api-endpoint');
    const messageDiv = document.getElementById('api-endpoint-message');
    const endpointsList = document.getElementById('api-endpoints-list');

    async function loadLabels() {
      try {
        const response = await fetch('/api/labels');
        const data = await response.json();
        if (data.status === 'success' && data.labels) {
          targetLabelSelect.innerHTML = '<option value="">-- Select Label --</option>';
          data.labels.forEach(label => {
            const option = document.createElement('option');
            option.value = label.name;
            option.textContent = label.name;
            targetLabelSelect.appendChild(option);
          });
        }
      } catch (err) {
        console.error('Failed to load labels:', err);
      }
    }

    async function loadEndpoints() {
      try {
        const response = await fetch('/api/settings/api-endpoints');
        const data = await response.json();

        if (data.status === 'success' && data.endpoints && data.endpoints.length > 0) {
          endpointsList.innerHTML = `
            <table class="table table-sm" style="width: 100%;">
              <thead>
                <tr>
                  <th>Name</th>
                  <th>URL</th>
                  <th>Auth</th>
                  <th>Label</th>
                  <th style="width: 180px;">Actions</th>
                </tr>
              </thead>
              <tbody id="endpoints-table-body">
              </tbody>
            </table>
          `;

          const tbody = document.getElementById('endpoints-table-body');
          data.endpoints.forEach(endpoint => {
            const row = document.createElement('tr');
            row.innerHTML = `
              <td>${escapeHtml(endpoint.name)}</td>
              <td><span class="small text-muted">${escapeHtml(endpoint.url.substring(0, 40))}${endpoint.url.length > 40 ? '...' : ''}</span></td>
              <td><span class="badge">${endpoint.auth_method}</span></td>
              <td>${endpoint.target_label ? escapeHtml(endpoint.target_label) : '<span class="text-muted">—</span>'}</td>
              <td>
                <button class="btn btn-xs btn-outline-primary" onclick="apiEndpointsTestById('${endpoint.id}')">Test</button>
                <button class="btn btn-xs btn-outline-secondary" onclick="apiEndpointsEdit('${endpoint.id}')">Edit</button>
                <button class="btn btn-xs btn-outline-danger" onclick="apiEndpointsDelete('${endpoint.id}')">Delete</button>
              </td>
            `;
            tbody.appendChild(row);
          });
        } else {
          endpointsList.innerHTML = '<p class="small" style="color: #999;"><em>No endpoints registered yet</em></p>';
        }
      } catch (err) {
        messageDiv.textContent = 'Failed to load endpoints: ' + err.message;
        messageDiv.style.color = 'red';
      }
    }

    function resetForm() {
      editingEndpointId = null;
      nameInput.value = '';
      urlInput.value = '';
      authMethodSelect.value = 'none';
      authValueInput.value = '';
      jsonPathInput.value = '';
      targetLabelSelect.value = '';
      btnSave.textContent = 'Save Endpoint';
      btnCancel.style.display = 'none';
      messageDiv.textContent = '';
    }

    async function testEndpoint() {
      const name = nameInput.value.trim();
      const url = urlInput.value.trim();

      if (!name || !url) {
        messageDiv.textContent = 'Name and URL are required';
        messageDiv.style.color = 'red';
        return;
      }

      // Create temporary endpoint for testing
      const tempData = {
        name: name + '_test_' + Date.now(),
        url: url,
        auth_method: authMethodSelect.value,
        auth_value: authValueInput.value.trim(),
        json_path: jsonPathInput.value.trim()
      };

      try {
        messageDiv.textContent = 'Creating test endpoint...';
        messageDiv.style.color = '#666';

        // Create temporary endpoint
        const createResp = await fetch('/api/settings/api-endpoints', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(tempData)
        });

        if (!createResp.ok) {
          const errorData = await createResp.json();
          throw new Error(errorData.error || 'Failed to create test endpoint');
        }

        const createData = await createResp.json();
        const tempId = createData.endpoint.id;

        // Test the endpoint
        messageDiv.textContent = 'Testing connection...';
        const testResp = await fetch(`/api/settings/api-endpoints/${tempId}/test`, {
          method: 'POST'
        });

        const testData = await testResp.json();

        // Delete temporary endpoint
        await fetch(`/api/settings/api-endpoints/${tempId}`, { method: 'DELETE' });

        if (testData.status === 'success' && testData.test_result) {
          const result = testData.test_result;
          if (result.success) {
            messageDiv.textContent = `✓ Connection successful! Found ${result.total_records} records. Sample: ${JSON.stringify(result.sample_data[0] || {}).substring(0, 100)}...`;
            messageDiv.style.color = 'green';
          } else {
            messageDiv.textContent = `✗ Test failed: ${result.error}`;
            messageDiv.style.color = 'red';
          }
        } else {
          throw new Error('Invalid test response');
        }
      } catch (err) {
        messageDiv.textContent = '✗ Test failed: ' + err.message;
        messageDiv.style.color = 'red';
      }
    }

    async function saveEndpoint() {
      const name = nameInput.value.trim();
      const url = urlInput.value.trim();

      if (!name || !url) {
        messageDiv.textContent = 'Name and URL are required';
        messageDiv.style.color = 'red';
        return;
      }

      const endpointData = {
        name: name,
        url: url,
        auth_method: authMethodSelect.value,
        auth_value: authValueInput.value.trim(),
        json_path: jsonPathInput.value.trim(),
        target_label: targetLabelSelect.value
      };

      try {
        let response;
        if (editingEndpointId) {
          // Update existing
          response = await fetch(`/api/settings/api-endpoints/${editingEndpointId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(endpointData)
          });
        } else {
          // Create new
          response = await fetch('/api/settings/api-endpoints', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(endpointData)
          });
        }

        const data = await response.json();

        if (data.status === 'success') {
          messageDiv.textContent = editingEndpointId ? 'Endpoint updated!' : 'Endpoint saved!';
          messageDiv.style.color = 'green';
          resetForm();
          await loadEndpoints();
          setTimeout(() => { messageDiv.textContent = ''; }, 3000);
        } else {
          messageDiv.textContent = 'Error: ' + (data.error || 'Unknown error');
          messageDiv.style.color = 'red';
        }
      } catch (err) {
        messageDiv.textContent = 'Save failed: ' + err.message;
        messageDiv.style.color = 'red';
      }
    }

    // Global functions for onclick handlers
    window.apiEndpointsEdit = async function(id) {
      try {
        const response = await fetch(`/api/settings/api-endpoints/${id}`);
        const data = await response.json();

        if (data.status === 'success' && data.endpoint) {
          const endpoint = data.endpoint;
          editingEndpointId = id;
          nameInput.value = endpoint.name;
          urlInput.value = endpoint.url;
          authMethodSelect.value = endpoint.auth_method;
          // Note: auth_value is not returned for security
          authValueInput.value = '';
          authValueInput.placeholder = 'Enter new value or leave empty to keep existing';
          jsonPathInput.value = endpoint.json_path || '';
          targetLabelSelect.value = endpoint.target_label || '';
          btnSave.textContent = 'Update Endpoint';
          btnCancel.style.display = 'inline-block';
          messageDiv.textContent = 'Editing: ' + endpoint.name;
          messageDiv.style.color = '#666';

          // Scroll to form
          nameInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      } catch (err) {
        alert('Failed to load endpoint: ' + err.message);
      }
    };

    window.apiEndpointsDelete = async function(id) {
      if (!confirm('Are you sure you want to delete this endpoint?')) {
        return;
      }

      try {
        const response = await fetch(`/api/settings/api-endpoints/${id}`, {
          method: 'DELETE'
        });
        const data = await response.json();

        if (data.status === 'success') {
          await loadEndpoints();
          messageDiv.textContent = 'Endpoint deleted';
          messageDiv.style.color = 'green';
          setTimeout(() => { messageDiv.textContent = ''; }, 2000);
        } else {
          alert('Delete failed: ' + (data.error || 'Unknown error'));
        }
      } catch (err) {
        alert('Delete failed: ' + err.message);
      }
    };

    window.apiEndpointsTestById = async function(id) {
      try {
        messageDiv.textContent = 'Testing connection...';
        messageDiv.style.color = '#666';

        const response = await fetch(`/api/settings/api-endpoints/${id}/test`, {
          method: 'POST'
        });
        const data = await response.json();

        if (data.status === 'success' && data.test_result) {
          const result = data.test_result;
          if (result.success) {
            messageDiv.textContent = `✓ Connection successful! Found ${result.total_records} records.`;
            messageDiv.style.color = 'green';
          } else {
            messageDiv.textContent = `✗ Test failed: ${result.error}`;
            messageDiv.style.color = 'red';
          }
        } else {
          messageDiv.textContent = '✗ Test failed: ' + (data.error || 'Unknown error');
          messageDiv.style.color = 'red';
        }

        setTimeout(() => { messageDiv.textContent = ''; }, 5000);
      } catch (err) {
        messageDiv.textContent = '✗ Test failed: ' + err.message;
        messageDiv.style.color = 'red';
        setTimeout(() => { messageDiv.textContent = ''; }, 5000);
      }
    };

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    if (btnTest) btnTest.addEventListener('click', testEndpoint);
    if (btnSave) btnSave.addEventListener('click', saveEndpoint);
    if (btnCancel) btnCancel.addEventListener('click', resetForm);

    // Load labels and endpoints on page load
    loadLabels();
    loadEndpoints();
    loadPluginEndpoints();
  }

  // Load and display plugin-registered endpoints
  async function loadPluginEndpoints() {
    const container = document.getElementById('plugin-endpoints-list');

    try {
      const response = await fetch('/api/settings/plugin-endpoints');
      const data = await response.json();

      if (data.status === 'success' && data.endpoints && data.endpoints.length > 0) {
        container.innerHTML = `
          <table class="table table-sm" style="width: 100%;">
            <thead>
              <tr>
                <th>Name</th>
                <th>Endpoint</th>
                <th>Label Type</th>
                <th>Plugin</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody id="plugin-endpoints-table-body">
            </tbody>
          </table>
        `;

        const tbody = document.getElementById('plugin-endpoints-table-body');
        data.endpoints.forEach(endpoint => {
          const row = document.createElement('tr');
          const authBadge = endpoint.auth_required ?
            '<span class="badge" style="background: #ff9800; color: white; margin-left: 0.25rem;">Auth Required</span>' : '';

          row.innerHTML = `
            <td>${escapeHtml(endpoint.name)}${authBadge}</td>
            <td><code class="small">${escapeHtml(endpoint.endpoint)}</code></td>
            <td><span class="badge">${escapeHtml(endpoint.label_type)}</span></td>
            <td><span class="small text-muted">${escapeHtml(endpoint.plugin)}</span></td>
            <td><span class="small">${escapeHtml(endpoint.description || '—')}</span></td>
          `;
          tbody.appendChild(row);
        });
      } else {
        container.innerHTML = '<p class="small" style="color: #999;"><em>No plugin endpoints registered</em></p>';
      }
    } catch (err) {
      console.error('Failed to load plugin endpoints:', err);
      container.innerHTML = '<p class="small" style="color: #e53935;"><em>Failed to load plugin endpoints</em></p>';
    }
  }

  // Table Format Registry Management
  function initTableFormats() {
    let editingFormatId = null;
    const nameInput = document.getElementById('table-format-name');
    const fileTypeSelect = document.getElementById('table-format-file-type');
    const delimiterInput = document.getElementById('table-format-delimiter');
    const encodingSelect = document.getElementById('table-format-encoding');
    const targetLabelSelect = document.getElementById('table-format-target-label');
    const hasHeaderCheck = document.getElementById('table-format-has-header');
    const descriptionInput = document.getElementById('table-format-description');
    const btnSave = document.getElementById('btn-save-table-format');
    const btnCancel = document.getElementById('btn-cancel-table-format');
    const uploadSample = document.getElementById('table-format-upload-sample');
    const messageDiv = document.getElementById('table-format-message');
    const formatsList = document.getElementById('table-formats-list');
    const previewDiv = document.getElementById('table-format-preview');
    const previewContent = document.getElementById('table-format-preview-content');

    // Update delimiter placeholder based on file type
    fileTypeSelect.addEventListener('change', () => {
      const fileType = fileTypeSelect.value;
      if (fileType === 'csv') {
        delimiterInput.value = ',';
        delimiterInput.disabled = false;
      } else if (fileType === 'tsv') {
        delimiterInput.value = '\t';
        delimiterInput.disabled = false;
      } else {
        delimiterInput.value = '';
        delimiterInput.disabled = true;
      }
    });

    async function loadLabels() {
      try {
        const response = await fetch('/api/labels');
        const data = await response.json();
        if (data.status === 'success' && data.labels) {
          targetLabelSelect.innerHTML = '<option value="">-- Select Label --</option>';
          data.labels.forEach(label => {
            const option = document.createElement('option');
            option.value = label.name;
            option.textContent = label.name;
            targetLabelSelect.appendChild(option);
          });
        }
      } catch (err) {
        console.error('Failed to load labels:', err);
      }
    }

    async function loadFormats() {
      try {
        const response = await fetch('/api/settings/table-formats');
        const data = await response.json();

        if (data.status === 'success' && data.formats && data.formats.length > 0) {
          formatsList.innerHTML = `
            <table class="table table-sm" style="width: 100%;">
              <thead>
                <tr>
                  <th>Name</th>
                  <th>Type</th>
                  <th>Delimiter</th>
                  <th>Encoding</th>
                  <th>Target Label</th>
                  <th style="width: 180px;">Actions</th>
                </tr>
              </thead>
              <tbody id="formats-table-body">
              </tbody>
            </table>
          `;

          const tbody = document.getElementById('formats-table-body');
          data.formats.forEach(format => {
            const row = document.createElement('tr');
            const badge = format.is_preprogrammed ? '<span class="badge" style="background: #19c37d; color: white; margin-left: 0.25rem;">Preprogrammed</span>' : '';
            row.innerHTML = `
              <td>${escapeHtml(format.name)}${badge}</td>
              <td><span class="badge">${format.file_type.toUpperCase()}</span></td>
              <td><span class="small text-muted">${format.delimiter || '—'}</span></td>
              <td><span class="small text-muted">${format.encoding}</span></td>
              <td>${format.target_label ? escapeHtml(format.target_label) : '<span class="text-muted">—</span>'}</td>
              <td>
                ${!format.is_preprogrammed ? `
                  <button class="btn btn-xs btn-outline-secondary" onclick="tableFormatsEdit('${format.id}')">Edit</button>
                  <button class="btn btn-xs btn-outline-danger" onclick="tableFormatsDelete('${format.id}')">Delete</button>
                ` : '<span class="small text-muted">Read-only</span>'}
              </td>
            `;
            tbody.appendChild(row);
          });
        } else {
          formatsList.innerHTML = '<p class="small" style="color: #999;"><em>No formats registered yet</em></p>';
        }
      } catch (err) {
        messageDiv.textContent = 'Failed to load formats: ' + err.message;
        messageDiv.style.color = 'red';
      }
    }

    function resetForm() {
      editingFormatId = null;
      nameInput.value = '';
      fileTypeSelect.value = 'csv';
      delimiterInput.value = ',';
      delimiterInput.disabled = false;
      encodingSelect.value = 'utf-8';
      targetLabelSelect.value = '';
      hasHeaderCheck.checked = true;
      descriptionInput.value = '';
      btnSave.textContent = 'Save Format';
      btnCancel.style.display = 'none';
      messageDiv.textContent = '';
      previewDiv.style.display = 'none';
    }

    async function saveFormat() {
      const name = nameInput.value.trim();
      const fileType = fileTypeSelect.value;

      if (!name) {
        messageDiv.textContent = 'Name is required';
        messageDiv.style.color = 'red';
        return;
      }

      const formatData = {
        name: name,
        file_type: fileType,
        delimiter: delimiterInput.value || null,
        encoding: encodingSelect.value,
        has_header: hasHeaderCheck.checked,
        header_row: hasHeaderCheck.checked ? 0 : null,
        target_label: targetLabelSelect.value || null,
        description: descriptionInput.value.trim() || null
      };

      try {
        let response;
        if (editingFormatId) {
          response = await fetch(`/api/settings/table-formats/${editingFormatId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(formatData)
          });
        } else {
          response = await fetch('/api/settings/table-formats', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(formatData)
          });
        }

        const data = await response.json();

        if (data.status === 'success') {
          messageDiv.textContent = editingFormatId ? 'Format updated!' : 'Format saved!';
          messageDiv.style.color = 'green';
          resetForm();
          await loadFormats();
          setTimeout(() => { messageDiv.textContent = ''; }, 3000);
        } else {
          messageDiv.textContent = 'Error: ' + (data.error || 'Unknown error');
          messageDiv.style.color = 'red';
        }
      } catch (err) {
        messageDiv.textContent = 'Save failed: ' + err.message;
        messageDiv.style.color = 'red';
      }
    }

    // Handle file upload for auto-detect
    uploadSample.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      messageDiv.textContent = 'Detecting format...';
      messageDiv.style.color = '#666';

      const formData = new FormData();
      formData.append('file', file);

      try {
        const response = await fetch('/api/settings/table-formats/detect', {
          method: 'POST',
          body: formData
        });
        const data = await response.json();

        if (data.status === 'success' && data.detected) {
          const detected = data.detected;

          // Update form fields
          if (!nameInput.value) {
            nameInput.value = file.name.split('.')[0] + ' Format';
          }
          fileTypeSelect.value = detected.file_type;
          fileTypeSelect.dispatchEvent(new Event('change'));
          if (detected.delimiter) {
            delimiterInput.value = detected.delimiter;
          }
          encodingSelect.value = detected.encoding;
          hasHeaderCheck.checked = detected.has_header;

          // Show detected columns
          if (detected.sample_columns && detected.sample_columns.length > 0) {
            previewContent.innerHTML = `
              <p class="small"><strong>Detected columns:</strong> ${detected.sample_columns.join(', ')}</p>
            `;
            previewDiv.style.display = 'block';
          }

          messageDiv.textContent = '✓ Format detected! Review and save.';
          messageDiv.style.color = 'green';
        } else {
          messageDiv.textContent = '✗ Detection failed: ' + (data.error || 'Unknown error');
          messageDiv.style.color = 'red';
        }
      } catch (err) {
        messageDiv.textContent = '✗ Detection failed: ' + err.message;
        messageDiv.style.color = 'red';
      }

      // Reset file input
      e.target.value = '';
    });

    // Global functions for onclick handlers
    window.tableFormatsEdit = async function(id) {
      try {
        const response = await fetch(`/api/settings/table-formats/${id}`);
        const data = await response.json();

        if (data.status === 'success' && data.format) {
          const format = data.format;
          editingFormatId = id;
          nameInput.value = format.name;
          fileTypeSelect.value = format.file_type;
          delimiterInput.value = format.delimiter || '';
          encodingSelect.value = format.encoding;
          targetLabelSelect.value = format.target_label || '';
          hasHeaderCheck.checked = format.has_header;
          descriptionInput.value = format.description || '';
          btnSave.textContent = 'Update Format';
          btnCancel.style.display = 'inline-block';
          messageDiv.textContent = 'Editing: ' + format.name;
          messageDiv.style.color = '#666';

          // Scroll to form
          nameInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      } catch (err) {
        alert('Failed to load format: ' + err.message);
      }
    };

    window.tableFormatsDelete = async function(id) {
      if (!confirm('Are you sure you want to delete this format?')) {
        return;
      }

      try {
        const response = await fetch(`/api/settings/table-formats/${id}`, {
          method: 'DELETE'
        });
        const data = await response.json();

        if (data.status === 'success') {
          await loadFormats();
          messageDiv.textContent = 'Format deleted';
          messageDiv.style.color = 'green';
          setTimeout(() => { messageDiv.textContent = ''; }, 2000);
        } else {
          alert('Delete failed: ' + (data.error || 'Unknown error'));
        }
      } catch (err) {
        alert('Delete failed: ' + err.message);
      }
    };

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    if (btnSave) btnSave.addEventListener('click', saveFormat);
    if (btnCancel) btnCancel.addEventListener('click', resetForm);

    // Initialize delimiter on page load
    fileTypeSelect.dispatchEvent(new Event('change'));

    // Load labels and formats
    loadLabels();
    loadFormats();
  }

  // Fuzzy Matching Settings Management
  function initFuzzyMatching() {
    const algorithmSelect = document.getElementById('fuzzy-algorithm');
    const thresholdInput = document.getElementById('fuzzy-threshold');
    const thresholdValue = document.getElementById('fuzzy-threshold-value');
    const caseSensitiveCheck = document.getElementById('fuzzy-case-sensitive');
    const normalizeWhitespaceCheck = document.getElementById('fuzzy-normalize-whitespace');
    const stripPunctuationCheck = document.getElementById('fuzzy-strip-punctuation');
    const phoneticSettings = document.getElementById('fuzzy-phonetic-settings');
    const phoneticEnabledCheck = document.getElementById('fuzzy-phonetic-enabled');
    const phoneticAlgorithmSelect = document.getElementById('fuzzy-phonetic-algorithm');
    const minLengthInput = document.getElementById('fuzzy-min-length');
    const maxComparisonsInput = document.getElementById('fuzzy-max-comparisons');
    const showConfidenceCheck = document.getElementById('fuzzy-show-confidence');
    const btnSave = document.getElementById('btn-save-fuzzy-settings');
    const btnReset = document.getElementById('btn-reset-fuzzy-settings');
    const messageDiv = document.getElementById('fuzzy-settings-message');

    // Update threshold value display
    thresholdInput.addEventListener('input', () => {
      thresholdValue.textContent = thresholdInput.value;
    });

    // Show/hide phonetic settings based on algorithm
    algorithmSelect.addEventListener('change', () => {
      if (algorithmSelect.value === 'phonetic') {
        phoneticSettings.style.display = 'block';
        phoneticEnabledCheck.checked = true;
      } else {
        phoneticSettings.style.display = 'none';
      }
    });

    async function loadSettings() {
      try {
        const response = await fetch('/api/settings/fuzzy-matching');
        const data = await response.json();

        if (data.status === 'success' && data.settings) {
          const settings = data.settings;

          algorithmSelect.value = settings.algorithm;
          thresholdInput.value = Math.round(settings.threshold * 100);
          thresholdValue.textContent = Math.round(settings.threshold * 100);
          caseSensitiveCheck.checked = settings.case_sensitive;
          normalizeWhitespaceCheck.checked = settings.normalize_whitespace;
          stripPunctuationCheck.checked = settings.strip_punctuation;
          phoneticEnabledCheck.checked = settings.phonetic_enabled;
          phoneticAlgorithmSelect.value = settings.phonetic_algorithm;
          minLengthInput.value = settings.min_string_length;
          maxComparisonsInput.value = settings.max_comparisons;
          showConfidenceCheck.checked = settings.show_confidence_scores;

          // Update phonetic settings visibility
          if (settings.algorithm === 'phonetic') {
            phoneticSettings.style.display = 'block';
          }
        }
      } catch (err) {
        console.error('Failed to load fuzzy matching settings:', err);
        messageDiv.textContent = 'Failed to load settings: ' + err.message;
        messageDiv.style.color = 'red';
      }
    }

    async function saveSettings() {
      const settingsData = {
        algorithm: algorithmSelect.value,
        threshold: parseFloat(thresholdInput.value) / 100.0,
        case_sensitive: caseSensitiveCheck.checked,
        normalize_whitespace: normalizeWhitespaceCheck.checked,
        strip_punctuation: stripPunctuationCheck.checked,
        phonetic_enabled: phoneticEnabledCheck.checked,
        phonetic_algorithm: phoneticAlgorithmSelect.value,
        min_string_length: parseInt(minLengthInput.value),
        max_comparisons: parseInt(maxComparisonsInput.value),
        show_confidence_scores: showConfidenceCheck.checked
      };

      try {
        const response = await fetch('/api/settings/fuzzy-matching', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(settingsData)
        });

        const data = await response.json();

        if (data.status === 'success') {
          messageDiv.textContent = 'Settings saved successfully!';
          messageDiv.style.color = 'green';
          setTimeout(() => { messageDiv.textContent = ''; }, 3000);
        } else {
          messageDiv.textContent = 'Error: ' + (data.error || 'Unknown error');
          messageDiv.style.color = 'red';
        }
      } catch (err) {
        messageDiv.textContent = 'Save failed: ' + err.message;
        messageDiv.style.color = 'red';
      }
    }

    async function resetSettings() {
      if (!confirm('Reset to default fuzzy matching settings?')) {
        return;
      }

      // Reset to defaults
      const defaults = {
        algorithm: 'levenshtein',
        threshold: 0.80,
        case_sensitive: false,
        normalize_whitespace: true,
        strip_punctuation: true,
        phonetic_enabled: false,
        phonetic_algorithm: 'metaphone',
        min_string_length: 3,
        max_comparisons: 10000,
        show_confidence_scores: true
      };

      try {
        const response = await fetch('/api/settings/fuzzy-matching', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(defaults)
        });

        const data = await response.json();

        if (data.status === 'success') {
          await loadSettings(); // Reload to reflect changes
          messageDiv.textContent = 'Reset to defaults!';
          messageDiv.style.color = 'green';
          setTimeout(() => { messageDiv.textContent = ''; }, 3000);
        }
      } catch (err) {
        messageDiv.textContent = 'Reset failed: ' + err.message;
        messageDiv.style.color = 'red';
      }
    }

    if (btnSave) btnSave.addEventListener('click', saveSettings);
    if (btnReset) btnReset.addEventListener('click', resetSettings);

    // Load settings on page load
    loadSettings();
  }

  // Initialize all integrations features
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      initAPIEndpoints();
      initTableFormats();
      initFuzzyMatching();
    });
  } else {
    initAPIEndpoints();
    initTableFormats();
    initFuzzyMatching();
  }
</script>
