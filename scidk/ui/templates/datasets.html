{% extends 'base.html' %}
{% block title %}SciDK - Files{% endblock %}
{% block content %}
<h1 data-testid="files-title">Files</h1>
<section data-testid="files-root">
  <h2>Files</h2>
  <div class="row g-2" style="margin-bottom:.5rem">
    <div class="col-auto">
      <label for="prov-select" class="form-label small" style="margin-bottom:.25rem">Provider</label>
      <select id="prov-select" class="form-select form-select-sm" style="min-width:220px"></select>
    </div>
    <div class="col-auto">
      <label for="root-select" class="form-label small" style="margin-bottom:.25rem">Root</label>
      <select id="root-select" class="form-select form-select-sm" style="min-width:240px"></select>
    </div>
    <div class="col-auto">
      <label for="prov-path" class="form-label small" style="margin-bottom:.25rem">Path</label>
      <input id="prov-path" type="text" class="form-control form-control-sm" placeholder="/path/within/root" style="width:360px" />
    </div>
    <div class="col-auto">
      <label class="form-label small" style="margin-bottom:.25rem">Browse options</label>
      <div class="small" style="display:flex; gap:.75rem; align-items:center; border:1px dashed #ddd; padding:.25rem .5rem; border-radius:.25rem">
        <div class="form-check form-check-inline">
          <input id="prov-browse-recursive" class="form-check-input" type="checkbox" />
          <label class="form-check-label small" for="prov-browse-recursive">Recursive</label>
        </div>
        <div class="form-check form-check-inline">
          <input id="prov-browse-fast-list" class="form-check-input" type="checkbox" />
          <label class="form-check-label small" for="prov-browse-fast-list">Fast list</label>
        </div>
        <div class="input-group input-group-sm" style="width: 160px;">
          <span class="input-group-text">Max depth</span>
          <input id="prov-browse-max-depth" type="number" class="form-control" min="1" step="1" value="1" />
        </div>
      </div>
    </div>
    <div class="col-auto" style="display:flex; gap:.5rem; align-items:end;">
      <button id="prov-go" class="btn btn-sm btn-outline-primary">Go</button>
    </div>
  </div>
  <div id="prov-crumb" class="small" style="margin-bottom:.5rem"></div>
  <div style="display:flex; gap:1rem; align-items:flex-start">
    <div style="flex: 2 1 60%; border:1px solid #eee; max-height:420px; overflow:auto">
      <table class="table table-sm" style="margin-bottom:0">
        <thead><tr><th>Name</th><th>Type</th><th>Size</th><th>Modified</th><th>Provider</th></tr></thead>
        <tbody id="prov-list"></tbody>
      </table>
    </div>
    <div id="prov-panel" style="flex: 1 1 40%; border:1px solid #eee; min-height:200px; padding:.5rem; position:sticky; top:1rem">
      <div class="small" id="prov-panel-content">
        <div style="margin-bottom:0.5rem; padding:0.5rem; background:#f8f9fa; border-radius:0.25rem">
          <strong>Current Location:</strong>
          <div id="prov-current-path" class="small" style="margin-top:0.25rem; font-family:monospace">
            No folder selected
          </div>
        </div>
        <div style="margin-top:0.5rem">
          <button id="prov-scan-btn" type="button" class="btn btn-sm btn-primary" style="width:100%" disabled>
            üîç Scan This Folder
          </button>
          <div class="small text-muted" style="margin-top:0.25rem">
            Select a folder to enable scanning. All scans run as background tasks with progress tracking.
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

{% if files_viewer == 'rocrate' %}
<section>
  <h2>RO-Crate Viewer</h2>
  <div class="row g-2" style="margin-bottom:.5rem; align-items: end;">
    <div class="col-auto" style="display:flex; gap:.5rem;">
      <button id="open-rocrate" class="btn btn-sm btn-outline-success">Open in RO-Crate Viewer</button>
      <button id="close-rocrate" class="btn btn-sm btn-outline-secondary" style="display:none">Close RO-Crate Viewer</button>
    </div>
    <div class="col small" id="rocrate-msg"></div>
  </div>
  <iframe id="rocrate-frame" style="width:100%; height:60vh; border:1px solid #ddd; display:none"></iframe>
  <div class="small" style="margin-top:.25rem">This experimental viewer uses a minimal JSON-LD from <code>/api/rocrate</code> (or wrapper). Large folders may be truncated.</div>
</section>
{% else %}
<div class="alert alert-secondary small" role="alert" style="margin-top:.5rem">
  RO-Crate viewer is disabled. Enable it by setting environment variable <code>SCIDK_FILES_VIEWER=rocrate</code>,
  or <a href="/datasets?files_viewer=rocrate">open this page with <code>?files_viewer=rocrate</code></a>.
</div>
{% endif %}

<section>
  <h2>Snapshot (scanned) browse</h2>
  <div class="row g-2" style="margin-bottom:.5rem">
    <div class="col-auto">
      <label for="snapshot-scan" class="form-label small" style="margin-bottom:.25rem">Scan</label>
      <select id="snapshot-scan" class="form-select form-select-sm" style="min-width:300px">
        <option value="">-- select a recent scan below --</option>
      </select>
    </div>
    <div class="col-auto">
      <label for="snap-path" class="form-label small" style="margin-bottom:.25rem">Path</label>
      <input id="snap-path" type="text" class="form-control form-control-sm" placeholder="(defaults to scan root)" style="width:360px" />
    </div>
    <div class="col-auto">
      <label class="form-label small" style="margin-bottom:.25rem">Filters</label>
      <div class="small" style="display:flex; gap:.75rem; align-items:center; border:1px dashed #ddd; padding:.25rem .5rem; border-radius:.25rem">
        <div class="input-group input-group-sm" style="width: 160px;">
          <span class="input-group-text">Type</span>
          <select id="snap-type" class="form-select form-select-sm">
            <option value="">any</option>
            <option value="folder">folder</option>
            <option value="file">file</option>
          </select>
        </div>
        <div class="input-group input-group-sm" style="width: 200px;">
          <span class="input-group-text">Ext</span>
          <input id="snap-ext" type="text" class="form-control" placeholder=".txt, .csv" />
        </div>
        <div class="input-group input-group-sm" style="width: 160px;">
          <span class="input-group-text">Page size</span>
          <input id="snap-page-size" type="number" class="form-control" min="1" max="1000" step="1" value="100" />
        </div>
      </div>
    </div>
    <div class="col-auto" style="display:flex; gap:.5rem; align-items:end;">
      <button id="snap-go" class="btn btn-sm btn-outline-primary">Browse</button>
      <button id="snap-prev" class="btn btn-sm btn-outline-secondary" disabled>Prev</button>
      <button id="snap-next" class="btn btn-sm btn-outline-secondary" disabled>Next</button>
      <button id="snap-use-live" class="btn btn-sm btn-outline-secondary" title="Copy Live path into Snapshot">Use Live path</button>
      <button id="snap-commit" class="btn btn-sm btn-outline-success" title="Commit selected scan to Graph">Commit selected scan</button>
    </div>
  </div>
  <div class="small" id="snap-crumb" style="margin-bottom:.25rem"></div>
  <div class="small" id="snap-status" style="margin-bottom:.5rem"></div>
  <div class="table-responsive" style="max-height:320px; overflow:auto; border:1px solid #eee">
    <table class="table table-sm" style="margin-bottom:0">
      <thead><tr><th>Name</th><th>Type</th><th>Size</th><th>Modified</th></tr></thead>
      <tbody id="snap-list"></tbody>
    </table>
  </div>
  <div class="row g-2" style="margin-top:.5rem">
    <div class="col-auto">
      <label class="form-label small" style="margin-bottom:.25rem">Snapshot search</label>
      <div class="input-group input-group-sm" style="width: 420px;">
        <input id="snap-search-q" type="text" class="form-control" placeholder="search name or path within scan" />
        <button id="snap-search-go" type="button" class="btn btn-outline-secondary">Search</button>
      </div>
    </div>
    <div class="col-auto">
      <div class="input-group input-group-sm" style="width: 200px;">
        <span class="input-group-text">Ext</span>
        <input id="snap-search-ext" type="text" class="form-control" placeholder=".txt" />
      </div>
    </div>
    <div class="col-auto">
      <div class="input-group input-group-sm" style="width: 320px;">
        <span class="input-group-text">Prefix</span>
        <input id="snap-search-prefix" type="text" class="form-control" placeholder="remote:folder or /abs/prefix" />
      </div>
    </div>
  </div>
  <div id="snap-search-results" class="small" style="margin-top:.25rem"></div>
</section>

<section>
  <h2>Scans Summary</h2>
  <div class="table-responsive" style="max-height:280px; overflow:auto; border:1px solid #eee">
    <table class="table table-sm" style="margin-bottom:0">
      <thead><tr>
        <th>ID</th><th>Path</th><th>Files</th><th>Recursive</th><th>Started</th><th>Ended</th><th>Committed</th>
      </tr></thead>
      <tbody id="scans-summary"></tbody>
    </table>
  </div>
</section>
<section>
  <h2>Scans Summary</h2>
  <div id="tasks-list" style="margin-top:.75rem"></div>

  <div class="actions" style="margin-top:1rem; align-items: baseline; gap: .5rem;">
    <label class="small" for="recent-scans">Recent scans:</label>
    <select id="recent-scans">
      <option value="">-- select --</option>
      {% for s in recent_scans or [] %}
        <option value="{{ s.id }}">{{ s.path }} ‚Äî {{ s.file_count }} files ‚Äî {{ '%.0f'|format((s.ended or s.started) or 0) }}</option>
      {% endfor %}
    </select>
    <button id="open-scan" type="button" class="btn btn-sm btn-outline-primary">Open</button>
    <button id="refresh-scans" type="button" class="btn btn-sm btn-outline-secondary">Refresh</button>
    {% if selected_scan %}
      <span class="small">Filtering by scan <code>{{ selected_scan.id }}</code> for <code>{{ selected_scan.path }}</code> (recursive: {{ selected_scan.recursive }}) ‚Äî <a href="/datasets">Clear filter</a></span>
    {% endif %}
  </div>

  <div id="neo4j-status" class="small" style="margin-top:.5rem; display:flex; align-items:center; gap:.5rem">
    <div id="neo4j-light-files" title="Disconnected" style="width:10px; height:10px; border-radius:50%; background:#000; border:1px solid #333;"></div>
    <span id="neo4j-status-text-files">Neo4j: Not connected</span>
  </div>
  <div id="scans-panel" style="margin-top:0.5rem"></div>

  {% if directories %}
    <details style="margin-top:.5rem;">
      <summary class="small">Previously scanned sources (this session)</summary>
      <ul>
        {% for d in directories %}
          <li>{% if d.provider_id %}<span class="badge">{{ d.provider_id }}</span> {% endif %}<code>{{ d.path }}</code> ‚Äî files: {{ d.scanned }}, recursive: {{ d.recursive }}{% if d.source %} ‚Äî <span class="badge">{{ d.source }}</span>{% endif %}</li>
        {% endfor %}
      </ul>
    </details>
  {% endif %}
</section>

{% endblock %}
{% block head %}
<script>
  window.addEventListener('DOMContentLoaded', () => {
    // Provider-aware browser
    const provSelect = document.getElementById('prov-select');
    const rootSelect = document.getElementById('root-select');
    const provGoBtn = document.getElementById('prov-go');
    const provPathInput = document.getElementById('prov-path');
    const provList = document.getElementById('prov-list');
    const provCrumb = document.getElementById('prov-crumb');
    const provPanel = document.getElementById('prov-panel-content');
    const provScanBtn = document.getElementById('prov-scan-btn');
    const provCurrentPath = document.getElementById('prov-current-path');
    const btnROC = document.getElementById('open-rocrate');
    const btnROCClose = document.getElementById('close-rocrate');
    const rocFrame = document.getElementById('rocrate-frame');
    const rocMsg = document.getElementById('rocrate-msg');
    let currentProv = null;
    let currentRoot = null;
    let currentPath = null;

    function fmtBytes(n){ if(!n) return ''; const s=['B','KB','MB','GB','TB']; let i=0; let v=n; while(v>=1024 && i<s.length-1){ v/=1024; i++; } return (Math.round(v*10)/10)+' '+s[i]; }
    function fmtTime(ts){ try { return new Date(ts*1000).toLocaleString(); } catch(e){ return String(ts); } }

    async function loadProviders(){
      try {
        const r = await fetch('/api/providers');
        const items = await r.json();
        provSelect.innerHTML = items.map(p => `<option value="${p.id}">${p.display_name}</option>`).join('');
        currentProv = items[0]?.id || 'local_fs';
        provSelect.value = currentProv;
        await loadRoots(currentProv);
      } catch(e){ provSelect.innerHTML = '<option>(failed)</option>'; }
    }

    async function loadRoots(providerId){
      try {
        const r = await fetch('/api/provider_roots?provider_id=' + encodeURIComponent(providerId));
        const roots = await r.json();
        if (!Array.isArray(roots)) { rootSelect.innerHTML = '<option>(none)</option>'; return; }
        rootSelect.innerHTML = roots.map(rt => `<option value="${rt.id}">${rt.name||rt.path||rt.id}</option>`).join('');
        currentRoot = roots[0]?.id || '/';
        rootSelect.value = currentRoot;
        // Reset current path and input: for rclone, use relative (empty)
        if (providerId === 'rclone') {
          currentPath = '';
          if (provPathInput) provPathInput.value = '';
          // Auto-browse rclone root immediately
          await browse(providerId, currentRoot, '');
        } else {
          currentPath = currentRoot;
          if (provPathInput) provPathInput.value = currentPath;
          // Auto-browse non-rclone root immediately
          await browse(providerId, currentRoot, currentPath);
        }
      } catch(e){ rootSelect.innerHTML = '<option>(failed)</option>'; }
    }

    function composePath(providerId, rootId, relOrAbs){
      if (providerId === 'rclone'){
        const remote = (rootId||'').endsWith(':') ? (rootId||'') : ((rootId||'') + ':');
        let rel = (relOrAbs||'').replace(/^\/+/, '');
        // If user pasted the remote prefix into the relative input, strip it
        if (rel && rel.startsWith(remote)) {
          rel = rel.slice(remote.length);
        }
        // Also strip any other "<name>:" prefix they might have pasted
        const colonIdx = rel.indexOf(':');
        if (colonIdx > 0) {
          rel = rel.slice(colonIdx + 1).replace(/^\/+/, '');
        }
        return rel ? (remote + rel) : remote;
      }
      return relOrAbs || rootId || '/';
    }

    function displayPathFor(providerId, rootId, relOrAbs){
      if (providerId === 'rclone'){
        return (relOrAbs||'');
      }
      return relOrAbs || rootId || '/';
    }

    async function browse(providerId, rootId, path){
      const fullPath = composePath(providerId||'local_fs', rootId||'/', path||'');
      const qs = new URLSearchParams({ provider_id: providerId||'local_fs', root_id: rootId||'/', path: fullPath });
      // Append rclone-specific browse options if selected
      if ((providerId||'') === 'rclone'){
        try {
          const chkRec = document.getElementById('prov-browse-recursive');
          const chkFast = document.getElementById('prov-browse-fast-list');
          const inpDepth = document.getElementById('prov-browse-max-depth');
          if (chkRec && chkRec.checked) qs.set('recursive', 'true');
          const d = Number(inpDepth && inpDepth.value ? inpDepth.value : '1');
          if (d && d !== 1) qs.set('max_depth', String(d));
          if (chkFast && chkFast.checked) qs.set('fast_list', 'true');
        } catch(_) { /* ignore UI options if missing */ }
      }
      try {
        const r = await fetch('/api/browse?' + qs.toString());
        const j = await r.json();
        // display breadcrumb: for rclone show Root‚ÜíRemote and relative path
        const disp = displayPathFor(providerId||'local_fs', rootId||'/', path||'');
        const label = (providerId==='rclone') ? `${(rootId||'').replace(/:$/,'')} ‚Üí ${disp||'(root)'}` : (fullPath||'/');
        provCrumb.innerHTML = `<span class="small">Path: <code>${label}</code></span>`;
        // Sync input to relative path for rclone; absolute otherwise
        currentPath = disp;
        if (provPathInput) provPathInput.value = currentPath;
        const rows = (j.entries||[]).map(e => {
          const type = e.type === 'folder' ? 'Folder' : 'File';
          const size = e.type === 'folder' ? '' : fmtBytes(e.size||0);
          const mod = fmtTime(e.mtime||0);
          const prov = providerId;
          return `<tr class="prov-item" data-id="${e.id}" data-type="${e.type}"><td>${e.name}</td><td>${type}</td><td>${size}</td><td>${mod}</td><td><span class="badge">${prov}</span></td></tr>`;
        }).join('');
        provList.innerHTML = rows || '<tr><td colspan="5" class="small">Empty folder.</td></tr>';
        attachProvHandlers();

        // Update current path display and enable scan button
        if (provCurrentPath) {
          provCurrentPath.textContent = fullPath || '(root)';
        }
        if (provScanBtn) {
          provScanBtn.disabled = false;
        }
      } catch(e){
        provList.innerHTML = '<tr><td colspan="5" class="small">Browse failed.</td></tr>';
        if (provScanBtn) provScanBtn.disabled = true;
      }
    }

    function attachProvHandlers(){
      document.querySelectorAll('tr.prov-item')?.forEach(tr => {
        tr.addEventListener('click', () => {
          const id = tr.getAttribute('data-id');
          const type = tr.getAttribute('data-type');
          if (type === 'folder'){
            // For rclone, set currentPath to relative portion (strip remote prefix)
            if (currentProv === 'rclone'){
              const i = id.indexOf(':');
              let rel = i >= 0 ? id.slice(i+1) : id;
              rel = (rel||'').replace(/^\/+/, '');
              currentPath = rel;
            } else {
              currentPath = id;
            }
            if (provPathInput) provPathInput.value = currentPath;
            browse(currentProv, currentRoot, currentPath);
          } else {
            provPanel.innerHTML = `<div><strong>${tr.firstChild?.textContent||id}</strong></div><div class=\"small\">Path: <code>${id}</code></div>`;
          }
        });
      });
    }

    if (provSelect){
      provSelect.addEventListener('change', async () => {
        currentProv = provSelect.value;
        await loadRoots(currentProv); // auto-browse happens in loadRoots
      });
    }
    if (rootSelect){
      rootSelect.addEventListener('change', () => {
        currentRoot = rootSelect.value;
        if (currentProv==='rclone'){
          currentPath='';
          if (provPathInput) provPathInput.value='';
          browse(currentProv, currentRoot, '');
        } else {
          currentPath = currentRoot;
          if (provPathInput) provPathInput.value = currentPath;
          browse(currentProv, currentRoot, currentPath);
        }
      });
    }
    if (btnROC && rocFrame){
      btnROC.addEventListener('click', () => {
        const provId = (provSelect && provSelect.value) || currentProv || 'local_fs';
        const rootId = (rootSelect && rootSelect.value) || currentRoot || '/';
        const path = (provPathInput && provPathInput.value) || currentPath || rootId || '/';
        const qs = new URLSearchParams({ provider_id: provId, root_id: rootId, path });
        rocFrame.src = '/rocrate_view?' + qs.toString();
        rocFrame.style.display = 'block';
        if (btnROCClose) btnROCClose.style.display = 'inline-block';
        if (rocMsg) rocMsg.textContent = 'Loading‚Ä¶';
        rocFrame.onload = () => { if (rocMsg) rocMsg.textContent = ''; };
      });
    }
    if (btnROCClose && rocFrame){
      btnROCClose.addEventListener('click', () => {
        rocFrame.style.display = 'none';
        rocFrame.src = '';
        if (btnROCClose) btnROCClose.style.display = 'none';
        if (rocMsg) rocMsg.textContent = 'Viewer closed.';
      });
    }
    if (provGoBtn){
      const doGo = () => {
        currentProv = provSelect.value; 
        currentRoot = rootSelect.value; 
        let rel = (provPathInput && provPathInput.value) ? provPathInput.value.trim() : (currentPath || '');
        // For rclone, keep empty to mean remote root; do not fallback to rootId string in the input
        if (currentProv === 'rclone' && !rel) rel = '';
        // For non-rclone, fallback to absolute root if empty
        if (currentProv !== 'rclone' && !rel) rel = currentRoot || '/';
        currentPath = rel; 
        browse(currentProv, currentRoot, currentPath);
      };
      provGoBtn.addEventListener('click', (e) => { e.preventDefault(); doGo(); });
      if (provPathInput){ provPathInput.addEventListener('keydown', (e) => { if (e.key === 'Enter'){ e.preventDefault(); doGo(); } }); }
      // Optional: re-browse on option changes for rclone
      const chkRec = document.getElementById('prov-browse-recursive');
      const chkFast = document.getElementById('prov-browse-fast-list');
      const inpDepth = document.getElementById('prov-browse-max-depth');
      const reBrowse = () => { if ((provSelect.value||'')==='rclone'){ doGo(); } };
      if (chkRec) chkRec.addEventListener('change', reBrowse);
      if (chkFast) chkFast.addEventListener('change', reBrowse);
      if (inpDepth) inpDepth.addEventListener('change', reBrowse);
    }

    // Unified scan button handler - uses background tasks
    if (provScanBtn){
      provScanBtn.addEventListener('click', async () => {
        // Get current browse context
        const provId = (provSelect && provSelect.value) || currentProv || 'local_fs';
        const rootId = (rootSelect && rootSelect.value) || currentRoot || '/';
        const inputPath = (provPathInput && provPathInput.value && provPathInput.value.trim()) || '';
        const relOrAbs = inputPath || currentPath || '';

        // Compose full scan path
        let scanPath = relOrAbs || rootId || '/';
        if (provId === 'rclone') {
          scanPath = composePath(provId, rootId, relOrAbs);
        }

        if (!provId || !scanPath){
          alert('Please select a provider and folder first.');
          return;
        }

        // Populate background scan form and trigger it
        const bgPathInput = document.getElementById('scan-path');
        const bgRecursive = document.getElementById('scan-recursive');
        if (bgPathInput) bgPathInput.value = scanPath;
        if (bgRecursive) bgRecursive.checked = true;

        // Trigger background scan via tasks API (same as "Start Background Scan" button)
        const recursive = true;
        provScanBtn.disabled = true;
        provScanBtn.textContent = 'Starting scan...';

        try {
          const payload = {
            type: 'scan',
            path: scanPath,
            recursive,
            provider_id: provId,
            root_id: rootId
          };
          const r = await fetch('/api/tasks', {
            method: 'POST',
            headers: { 'Content-Type':'application/json' },
            body: JSON.stringify(payload)
          });

          if (r.status === 202){
            startPolling();
            fetchTasks();
            alert(`Background scan started for: ${scanPath}\nCheck progress in "Scans Summary" section below.`);
          } else {
            const j = await r.json();
            alert('Scan error: ' + (j.error || r.status));
          }
        } catch(err){
          alert('Scan error: ' + err);
        } finally {
          provScanBtn.disabled = false;
          provScanBtn.textContent = 'üîç Scan This Folder';
        }
      });
    }

    // Snapshot browse logic (index-backed)
    const snapScanSel = document.getElementById('snapshot-scan');
    const snapPathInput = document.getElementById('snap-path');
    const snapTypeSel = document.getElementById('snap-type');
    const snapExtInput = document.getElementById('snap-ext');
    const snapPageSize = document.getElementById('snap-page-size');
    const snapGo = document.getElementById('snap-go');
    const snapPrev = document.getElementById('snap-prev');
    const snapNext = document.getElementById('snap-next');
    const snapUseLive = document.getElementById('snap-use-live');
    const snapCommit = document.getElementById('snap-commit');
    const snapStatus = document.getElementById('snap-status');
    const snapSearchQ = document.getElementById('snap-search-q');
    const snapSearchExt = document.getElementById('snap-search-ext');
    const snapSearchPrefix = document.getElementById('snap-search-prefix');
    const snapSearchBtn = document.getElementById('snap-search-go');
    const snapSearchResults = document.getElementById('snap-search-results');
    const snapList = document.getElementById('snap-list');
    const snapCrumb = document.getElementById('snap-crumb');
    let snapToken = null;
    let snapHistory = [];
    async function loadScansForSnapshot(){
      try{ const r = await fetch('/api/scans'); const scans = await r.json(); if (!snapScanSel) return; const current = snapScanSel.value; snapScanSel.innerHTML = '<option value="">-- select a recent scan below --</option>' + scans.map(s => `<option value="${s.id}">${s.path} ‚Äî ${s.file_count} files</option>`).join(''); if (current) snapScanSel.value = current; } catch(e) { /* ignore */ }
    }
    async function browseSnapshot(direction){
      if (!snapScanSel || !snapScanSel.value){ snapList.innerHTML = '<tr><td colspan="4" class="small">Select a scan first.</td></tr>'; return; }
      const scanId = snapScanSel.value;
      const path = (snapPathInput && snapPathInput.value.trim()) || '';
      const type = (snapTypeSel && snapTypeSel.value) || '';
      const ext = (snapExtInput && snapExtInput.value.trim()) || '';
      const ps = Number((snapPageSize && snapPageSize.value) || '100') || 100;
      const qs = new URLSearchParams({ page_size: String(ps) });
      if (path !== '') qs.set('path', path);
      if (type) qs.set('type', type);
      if (ext) qs.set('extension', ext.toLowerCase());
      if (direction === 'next' && snapToken) qs.set('next_page_token', snapToken);
      if (direction === 'prev'){
        // naive prev: step back one page using history
        if (snapHistory.length >= 2){ snapHistory.pop(); const prevTok = snapHistory.pop(); if (prevTok) qs.set('next_page_token', prevTok); else qs.delete('next_page_token'); }
      }
      try{
        const r = await fetch(`/api/scans/${encodeURIComponent(scanId)}/browse?` + qs.toString());
        const j = await r.json();
        if (!r.ok){ snapList.innerHTML = `<tr><td colspan="4" class="small">Error: ${j.error||r.status}</td></tr>`; return; }
        const entries = j.entries||[];
        snapToken = j.next_page_token || null;
        if (direction !== 'prev') snapHistory.push(j.next_page_token || '');
        // Update crumb with clickable ancestors
        const p = j.path || '';
        let parts = [];
        if (p){
          if (p.includes(':')){ const i = p.indexOf(':'); const rem = p.slice(0,i+1); const suff = p.slice(i+1).replace(/^\/+/, ''); const segs = suff? suff.split('/'): []; let acc = rem; parts.push({name: rem.replace(/:$/,''), path: rem}); for (let s of segs){ acc = acc + (acc.endsWith(':')? '':'/') + s; parts.push({name: s, path: acc}); }
          } else { const segs = p.replace(/^\/+/, '').split('/'); let acc = ''; for (let i=0;i<segs.length;i++){ acc = (i===0? ('/'+segs[i]) : (acc + '/' + segs[i])); parts.push({name: segs[i]||'/', path: acc}); } }
        }
        const crumbHtml = parts.length? parts.map((c, idx) => `<a href="#" data-snap-path="${c.path}">${c.name||'/'}</a>`).join(' / ') : '(scan root)';
        snapCrumb.innerHTML = `<span class="small">Scan <code>${scanId}</code> ‚Äî Path: ${crumbHtml} ‚Äî Showing ${entries.length}${snapToken?(' (next token '+snapToken+')'):''}</span>`;
        // attach crumb handlers
        snapCrumb.querySelectorAll('a[data-snap-path]')?.forEach(a => {
          a.addEventListener('click', (ev) => { ev.preventDefault(); const np = a.getAttribute('data-snap-path'); if (snapPathInput){ snapPathInput.value = np||''; snapToken=null; snapHistory=[]; browseSnapshot(); } });
        });
        // Render
        const rows = entries.map(e => {
          const mod = (e.modified && e.modified > 0 && e.type==='file') ? fmtTime(e.modified) : '';
          return `<tr data-path="${e.path}" data-type="${e.type}"><td>${e.name}</td><td>${e.type}</td><td>${e.type==='file'?(fmtBytes(e.size||0)):''}</td><td>${mod}</td></tr>`;
        }).join('');
        snapList.innerHTML = rows || '<tr><td colspan="4" class="small">No entries.</td></tr>';
        snapNext.disabled = !snapToken;
        snapPrev.disabled = (snapHistory.length <= 1);
        // Click to drill when folder
        document.querySelectorAll('#snap-list tr')?.forEach(tr => {
          tr.addEventListener('click', () => {
            const t = tr.getAttribute('data-type'); const p = tr.getAttribute('data-path');
            if (t === 'folder' && snapPathInput){ snapPathInput.value = p; snapToken = null; snapHistory = []; browseSnapshot(); }
          });
        });
      } catch(e){
        snapList.innerHTML = `<tr><td colspan="4" class="small">Browse failed.</td></tr>`;
      }
    }
    if (snapGo){ snapGo.addEventListener('click', () => { snapToken = null; snapHistory = []; browseSnapshot(); }); }
    if (snapNext){ snapNext.addEventListener('click', () => browseSnapshot('next')); }
    if (snapPrev){ snapPrev.addEventListener('click', () => browseSnapshot('prev')); }
    if (snapSearchBtn){ snapSearchBtn.addEventListener('click', async () => {
      if (!snapScanSel || !snapScanSel.value){ snapSearchResults.textContent = 'Select a scan first.'; return; }
      const qs = new URLSearchParams();
      const q = (snapSearchQ && snapSearchQ.value.trim()) || '';
      const ext = (snapSearchExt && snapSearchExt.value.trim()) || '';
      const prefix = (snapSearchPrefix && snapSearchPrefix.value.trim()) || '';
      if (q) qs.set('q', q);
      if (ext) qs.set('ext', ext);
      if (prefix) qs.set('prefix', prefix);
      qs.set('scan_id', snapScanSel.value);
      try{
        const r = await fetch('/api/index/search?' + qs.toString());
        const j = await r.json();
        if (!r.ok){ snapSearchResults.textContent = 'Search error: ' + (j.error||r.status); return; }
        const rows = (j.results||[]).map(it => `<div><code>${it.path}</code> ‚Äî ${it.ext||''} ${it.size?('('+fmtBytes(it.size)+')'):''}</div>`).join('');
        snapSearchResults.innerHTML = rows || '<div class="small">No matches.</div>';
      } catch(e){ snapSearchResults.textContent = 'Search error: ' + e; }
    }); }
    if (snapScanSel){ snapScanSel.addEventListener('change', () => { snapToken = null; snapHistory = []; browseSnapshot(); }); }
    if (snapUseLive){ snapUseLive.addEventListener('click', () => {
      const provId = (provSelect && provSelect.value) || currentProv || 'local_fs';
      const rootId = (rootSelect && rootSelect.value) || currentRoot || '/';
      const relOrAbs = (provPathInput && provPathInput.value && provPathInput.value.trim()) || currentPath || '';
      const full = provId === 'rclone' ? composePath(provId, rootId, relOrAbs) : (relOrAbs || rootId || '/');
      if (snapPathInput) snapPathInput.value = full;
    }); }
    if (snapCommit){ snapCommit.addEventListener('click', async () => {
      if (!snapScanSel || !snapScanSel.value){ snapStatus.textContent = 'Select a scan first.'; return; }
      const id = snapScanSel.value; snapCommit.disabled = true; const prev = snapCommit.textContent; snapCommit.textContent = 'Committing‚Ä¶'; snapStatus.textContent = '';
      try{ const r = await fetch('/api/tasks', { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ type: 'commit', scan_id: id }) }); if (r.status === 202){ snapStatus.textContent = 'Commit started in background. Watch progress above.'; } else { const j = await r.json(); snapStatus.textContent = 'Commit failed: ' + (j.error || r.status); } }
      catch(e){ snapStatus.textContent = 'Commit failed: ' + e; }
      finally { snapCommit.disabled = false; snapCommit.textContent = prev; }
    }); }

    // Scans dropdown and background tasks
    // Recent scans dropdown helpers
    const select = document.getElementById('recent-scans');
    const btnOpen = document.getElementById('open-scan');
    const refreshBtn = document.getElementById('refresh-scans');
    function openSelected(){ const id = select && select.value; if (id) { window.location = '/datasets?scan_id=' + encodeURIComponent(id); } }
    if (select && btnOpen) {
      btnOpen.addEventListener('click', openSelected);
      select.addEventListener('change', openSelected);
    }
    async function loadScansIntoDropdown(){
      try {
        const r = await fetch('/api/scans');
        const scans = await r.json();
        if (!select) return;
        const current = select.value;
        select.innerHTML = '<option value="">-- select --</option>' + scans.map(s => `<option value="${s.id}">${s.path} ‚Äî ${s.file_count} files ‚Äî ${Math.round(s.ended||s.started||0)}</option>`).join('');
        if (current) select.value = current;
      } catch(e) { /* ignore */ }
    }
    if (refreshBtn) refreshBtn.addEventListener('click', loadScansIntoDropdown);

    const tasksDiv = document.getElementById('tasks-list');
    // Keep a small client-side list for local (synchronous) scans so they appear alongside server tasks
    window.scidkLocalTasks = window.scidkLocalTasks || [];
    const fmtPct = (x) => Math.round((x || 0) * 100);
    function renderTasks(tasks){
      if (!tasks || tasks.length === 0){ tasksDiv.innerHTML = '<p class="small">No background tasks.</p>'; return; }
      tasksDiv.innerHTML = tasks.map(t => {
        const total = (t.total===null||t.total===undefined) ? '?' : (t.total||0);
        const pct = fmtPct(t.progress);
        const bar = `<div style=\"width:100%; background:#eee; height:10px; border-radius:4px; overflow:hidden\"><div style=\"width:${pct}%; height:10px; background:${t.status==='completed'?'#4caf50':(t.status==='error'?'#e53935':'#2196f3')}\"></div></div>`;
        let extra = '';
        if (t.type === 'commit'){
          const attempted = t.neo4j_attempted ? 'yes' : 'no';
          const written = (t.neo4j_written===undefined||t.neo4j_written===null) ? '' : String(t.neo4j_written);
          const dbv = (t.neo4j_db_verified===undefined) ? '' : (t.neo4j_db_verified ? 'ok' : 'fail');
          const dbf = (t.neo4j_db_files||0);
          const dbfo = (t.neo4j_db_folders||0);
          const err = t.neo4j_error ? (` ‚Äî error: ${t.neo4j_error}`) : '';
          extra = `<div class=\"small\">Neo4j: attempted=${attempted}${written!==''?(' ‚Äî prepared='+written):''}${dbv!==''?(' ‚Äî verify='+dbv+' (files:'+dbf+', folders:'+dbfo+')'):''}${err}</div>`;
        }
        const cancelBtn = (t.status==='running') ? ` <button class=\"btn btn-sm btn-outline-danger\" data-cancel=\"${t.id}\">Cancel</button>` : '';
        const info = `<div class=\"small\">${t.type} ${t.status} ‚Äî ${t.path || ''} ‚Äî ${t.processed||0}/${total} (${pct}%) ${t.error?(' ‚Äî error: '+t.error):''} ${t.scan_id?(' ‚Äî <a href=\"/datasets?scan_id='+t.scan_id+'\">open</a>'):''} ${cancelBtn}</div>`;
        return `<div style=\"margin:.25rem 0\">${bar}${info}${extra}</div>`;
      }).join('');
      // Attach cancel handlers
      tasksDiv.querySelectorAll('button[data-cancel]')?.forEach(btn => {
        btn.addEventListener('click', async () => {
          const id = btn.getAttribute('data-cancel');
          try {
            const r = await fetch('/api/tasks/' + encodeURIComponent(id) + '/cancel', { method: 'POST' });
            if (!r.ok) {
              try { const j = await r.json(); alert('Cancel failed: ' + (j.error || r.status)); }
              catch(_) { alert('Cancel failed: ' + r.status); }
            }
          } catch (e) {
            alert('Cancel failed: ' + e);
          } finally {
            try { fetchTasks(); } catch(_) { /* ignore */ }
          }
        });
      });
    }
    async function fetchTasks(){
      try { const r = await fetch('/api/tasks'); const data = await r.json(); const all = ([]).concat(Array.isArray(data)?data:[]).concat(window.scidkLocalTasks||[]); renderTasks(all); }
      catch(e){ /* ignore */ }
    }
    let poller = null;
    async function fetchNeoStatus(){
      try {
        const r = await fetch('/api/settings/neo4j');
        const j = await r.json();
        const light = document.getElementById('neo4j-light-files');
        const txt = document.getElementById('neo4j-status-text-files');
        const ok = !!(j && j.connected);
        if (light) { light.style.background = ok ? '#19c37d' : '#000'; light.title = ok ? 'Connected' : 'Disconnected'; }
        if (txt) { txt.textContent = ok ? 'Neo4j: Connected' : (j && j.last_error ? ('Neo4j: Error ‚Äî ' + j.last_error) : 'Neo4j: Not connected'); }
      } catch(e) {
        const txt = document.getElementById('neo4j-status-text-files');
        if (txt) txt.textContent = 'Neo4j: status unavailable';
      }
    }
    function renderScansSummaryRows(scans){
      const tbody = document.getElementById('scans-summary');
      if (!tbody) return;
      const fmtTs = (t) => { try { return t ? new Date(Math.round(t)*1000).toLocaleString() : ''; } catch(_) { return t || ''; } };
      if (!scans || scans.length === 0){ tbody.innerHTML = '<tr><td colspan="7" class="small">No scans yet.</td></tr>'; return; }
      tbody.innerHTML = scans.map(s => `<tr>
        <td><code>${s.id}</code></td>
        <td>${s.path}</td>
        <td>${s.file_count||0}</td>
        <td>${s.recursive?'yes':'no'}</td>
        <td>${fmtTs(s.started)}</td>
        <td>${fmtTs(s.ended)}</td>
        <td>${s.committed?'yes':'no'}</td>
      </tr>`).join('');
    }
    async function startPolling(){
      if (poller) return;
      poller = setInterval(async () => {
        try {
          const r = await fetch('/api/scans');
          const scans = await r.json();
          renderScansSummaryRows(scans);
        } catch(e){ /* ignore */ }
        fetchTasks();
        loadScansIntoDropdown();
        loadScansForSnapshot();
        renderScansPanel();
        fetchNeoStatus();
      }, 1000);
    }
    function stopPolling(){ if (poller){ clearInterval(poller); poller = null; } }

    // initial render
    startPolling(); fetchTasks(); loadScansIntoDropdown(); fetchNeoStatus();

    // Scans management panel
    const scansDiv = document.getElementById('scans-panel');
    function scansRow(s){
      const ts = Math.round(s.ended||s.started||0);
      return `<div style="padding:.25rem 0; border-bottom:1px solid #eee; display:flex; gap:.5rem; align-items:center; justify-content:space-between">
        <div class="small"><code>${s.id}</code> ‚Äî ${s.path} ‚Äî files: ${s.file_count} ‚Äî ${s.recursive?'recursive':'shallow'} ‚Äî ${ts}</div>
        <div style="display:flex; gap:.5rem">
          <a class="btn btn-sm btn-outline-primary" href="/datasets?scan_id=${s.id}">Open</a>
          <button class="btn btn-sm btn-outline-success" data-scan="${s.id}" data-action="commit">Commit to Graph</button>
          <button class="btn btn-sm btn-outline-danger" data-scan="${s.id}" data-action="delete">Delete</button>
        </div>
      </div>`;
    }
    async function renderScansPanel(){
      try { const r = await fetch('/api/scans'); const scans = await r.json(); scansDiv.innerHTML = scans.map(scansRow).join('') || '<p class="small">No scans yet.</p>'; }
      catch(e){ scansDiv.innerHTML = '<p class="small">Failed to load scans.</p>'; }
      // attach handlers
      scansDiv.querySelectorAll('button[data-action]')?.forEach(btn => {
        btn.addEventListener('click', async () => {
          const id = btn.getAttribute('data-scan');
          const action = btn.getAttribute('data-action');
          try {
            if (action === 'commit'){
              // Start background commit task to show progress in the Tasks panel
              const r = await fetch('/api/tasks', { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ type: 'commit', scan_id: id }) })
              if (r.status === 202){
                alert('Commit started in background. Watch progress above.');
                startPolling(); fetchTasks();
              } else {
                const j = await r.json();
                alert('Commit task error: ' + (j.error || r.status));
              }
            } else if (action === 'delete'){
              const r = await fetch('/api/scans/' + encodeURIComponent(id), { method: 'DELETE' });
              if (!r.ok){ const j = await r.json(); alert('Delete failed: ' + (j.error || r.status)); }
            }
          } catch(err){ alert('Action failed: ' + err); }
          renderScansPanel();
          loadScansIntoDropdown();
        });
      });
    }
    renderScansPanel();

    // File Browser logic
    // Initialize provider UI
    if (provSelect){ loadProviders(); }
  });
</script>
{% endblock %}