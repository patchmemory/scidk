{% extends 'base.html' %}
{% block title %}SciDK - Files{% endblock %}
{% block content %}
<h1>Files</h1>
<section>
  <h2>Files</h2>
  <div class="row g-2" style="margin-bottom:.5rem">
    <div class="col-auto">
      <label for="prov-select" class="form-label small" style="margin-bottom:.25rem">Provider</label>
      <select id="prov-select" class="form-select form-select-sm" style="min-width:220px"></select>
    </div>
    <div class="col-auto">
      <label for="root-select" class="form-label small" style="margin-bottom:.25rem">Root</label>
      <select id="root-select" class="form-select form-select-sm" style="min-width:240px"></select>
    </div>
    <div class="col-auto">
      <label for="prov-path" class="form-label small" style="margin-bottom:.25rem">Path</label>
      <input id="prov-path" type="text" class="form-control form-control-sm" placeholder="/path/within/root" style="width:360px" />
    </div>
    <div class="col-auto">
      <label class="form-label small" style="margin-bottom:.25rem">Browse options</label>
      <div class="small" style="display:flex; gap:.75rem; align-items:center; border:1px dashed #ddd; padding:.25rem .5rem; border-radius:.25rem">
        <div class="form-check form-check-inline">
          <input id="prov-browse-recursive" class="form-check-input" type="checkbox" />
          <label class="form-check-label small" for="prov-browse-recursive">Recursive</label>
        </div>
        <div class="form-check form-check-inline">
          <input id="prov-browse-fast-list" class="form-check-input" type="checkbox" />
          <label class="form-check-label small" for="prov-browse-fast-list">Fast list</label>
        </div>
        <div class="input-group input-group-sm" style="width: 160px;">
          <span class="input-group-text">Max depth</span>
          <input id="prov-browse-max-depth" type="number" class="form-control" min="1" step="1" value="1" />
        </div>
      </div>
    </div>
    <div class="col-auto" style="display:flex; gap:.5rem; align-items:end;">
      <button id="prov-go" class="btn btn-sm btn-outline-primary">Go</button>
    </div>
  </div>
  <div id="prov-crumb" class="small" style="margin-bottom:.5rem"></div>
  <div style="display:flex; gap:1rem; align-items:flex-start">
    <div style="flex: 2 1 60%; border:1px solid #eee; max-height:420px; overflow:auto">
      <table class="table table-sm" style="margin-bottom:0">
        <thead><tr><th><input id="prov-sel-all" type="checkbox" title="Select/Deselect all on page" /></th><th>Name</th><th>Type</th><th>Size</th><th>Modified</th><th>Provider</th></tr></thead>
        <tbody id="prov-list"></tbody>
      </table>
    </div>
    <div id="prov-panel" style="flex: 1 1 40%; border:1px solid #eee; min-height:200px; padding:.5rem; position:sticky; top:1rem">
      <div class="small" id="prov-panel-content">Select a provider, root, and item to see details.
        <div style="margin-top:.5rem">
          <form id="prov-scan-form" class="row g-2">
            <div class="col-auto small">Scan selected folder (recursive):</div>
            <div class="col-auto form-check">
              <input id="prov-scan-recursive" class="form-check-input" type="checkbox" checked />
              <label class="form-check-label small" for="prov-scan-recursive">Recursive</label>
            </div>
            <div class="col-auto">
              <button type="submit" class="btn btn-sm btn-primary">Scan</button>
            </div>
          </form>
          <div class="small" id="prov-scan-msg" style="margin-top:.25rem"></div>
          <div class="small" id="prov-select-panel" style="margin-top:.5rem; border-top:1px dashed #eee; padding-top:.5rem">
            <div style="display:flex; gap:.5rem; align-items:center; flex-wrap: wrap;">
              <label class="form-check-label small" title="If on, explicit includes can override .scidkignore patterns"><input id="sel-override-ignore" class="form-check-input" type="checkbox" checked /> Allow includes to override .scidkignore</label>
              <button id="btn-scan-with-selection" class="btn btn-sm btn-outline-primary">Scan with selection</button>
              <span id="sel-summary" class="small"></span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

{% if files_viewer == 'rocrate' %}
<section>
  <h2>RO-Crate Viewer</h2>
  <div class="row g-2" style="margin-bottom:.5rem; align-items: end;">
    <div class="col-auto" style="display:flex; gap:.5rem;">
      <button id="open-rocrate" class="btn btn-sm btn-outline-success">Open in RO-Crate Viewer</button>
      <button id="close-rocrate" class="btn btn-sm btn-outline-secondary" style="display:none">Close RO-Crate Viewer</button>
    </div>
    <div class="col small" id="rocrate-msg"></div>
  </div>
  <iframe id="rocrate-frame" style="width:100%; height:60vh; border:1px solid #ddd; display:none"></iframe>
  <div class="small" style="margin-top:.25rem">This experimental viewer uses a minimal JSON-LD from <code>/api/rocrate</code> (or wrapper). Large folders may be truncated.</div>
</section>
{% else %}
<div class="alert alert-secondary small" role="alert" style="margin-top:.5rem">
  RO-Crate viewer is disabled. Enable it by setting environment variable <code>SCIDK_FILES_VIEWER=rocrate</code>,
  or <a href="/datasets?files_viewer=rocrate">open this page with <code>?files_viewer=rocrate</code></a>.
</div>
{% endif %}

<section>
  <h2>Snapshot (scanned) browse</h2>
  <div class="row g-2" style="margin-bottom:.5rem">
    <div class="col-auto">
      <label for="snapshot-scan" class="form-label small" style="margin-bottom:.25rem">Scan</label>
      <select id="snapshot-scan" class="form-select form-select-sm" style="min-width:300px">
        <option value="">-- select a recent scan below --</option>
      </select>
    </div>
    <div class="col-auto">
      <label for="snap-path" class="form-label small" style="margin-bottom:.25rem">Path</label>
      <input id="snap-path" type="text" class="form-control form-control-sm" placeholder="(defaults to scan root)" style="width:360px" />
    </div>
    <div class="col-auto">
      <label class="form-label small" style="margin-bottom:.25rem">Filters</label>
      <div class="small" style="display:flex; gap:.75rem; align-items:center; border:1px dashed #ddd; padding:.25rem .5rem; border-radius:.25rem">
        <div class="input-group input-group-sm" style="width: 160px;">
          <span class="input-group-text">Type</span>
          <select id="snap-type" class="form-select form-select-sm">
            <option value="">any</option>
            <option value="folder">folder</option>
            <option value="file">file</option>
          </select>
        </div>
        <div class="input-group input-group-sm" style="width: 200px;">
          <span class="input-group-text">Ext</span>
          <input id="snap-ext" type="text" class="form-control" placeholder=".txt, .csv" />
        </div>
        <div class="input-group input-group-sm" style="width: 160px;">
          <span class="input-group-text">Page size</span>
          <input id="snap-page-size" type="number" class="form-control" min="1" max="1000" step="1" value="100" />
        </div>
      </div>
    </div>
    <div class="col-auto" style="display:flex; gap:.5rem; align-items:end;">
      <button id="snap-go" class="btn btn-sm btn-outline-primary">Browse</button>
      <button id="snap-prev" class="btn btn-sm btn-outline-secondary" disabled>Prev</button>
      <button id="snap-next" class="btn btn-sm btn-outline-secondary" disabled>Next</button>
      <button id="snap-use-live" class="btn btn-sm btn-outline-secondary" title="Copy Live path into Snapshot">Use Live path</button>
      <button id="snap-commit" class="btn btn-sm btn-outline-success" title="Commit selected scan to Graph">Commit selected scan</button>
      <button id="snap-rescan" class="btn btn-sm btn-outline-warning" title="Run the scan again using saved selection">Rescan</button>
      <button id="snap-reinterpret" class="btn btn-sm btn-outline-secondary" title="Populate interpretations for selected scan">Re-interpret scan</button>
    </div>
  </div>
  <div class="small" id="snap-crumb" style="margin-bottom:.25rem"></div>
  <div class="small" id="snap-status" style="margin-bottom:.5rem"></div>
  <div id="rclone-banner" class="small" style="display:none; margin-top:.5rem; padding:.5rem; border:1px dashed #cc9; background:#fffbf0">
    This rclone scan is large. For better performance, consider mounting the remote and re-running the scan. You can also proceed with streaming reinterpretation in chunks.
  </div>
  <div class="table-responsive" style="max-height:320px; overflow:auto; border:1px solid #eee">
    <table class="table table-sm" style="margin-bottom:0">
      <thead><tr><th>Name</th><th>Type</th><th>Size</th><th>Modified</th></tr></thead>
      <tbody id="snap-list"></tbody>
    </table>
  </div>
  <div id="snap-panel" class="small" style="margin-top:.5rem; border:1px solid #eee; padding:.5rem; display:none"></div>
  <div class="row g-2" style="margin-top:.5rem">
    <div class="col-auto">
      <label class="form-label small" style="margin-bottom:.25rem">Snapshot search</label>
      <div class="input-group input-group-sm" style="width: 420px;">
        <input id="snap-search-q" type="text" class="form-control" placeholder="search name or path within scan" />
        <button id="snap-search-go" type="button" class="btn btn-outline-secondary">Search</button>
      </div>
    </div>
    <div class="col-auto">
      <div class="input-group input-group-sm" style="width: 200px;">
        <span class="input-group-text">Ext</span>
        <input id="snap-search-ext" type="text" class="form-control" placeholder=".txt" />
      </div>
    </div>
    <div class="col-auto">
      <div class="input-group input-group-sm" style="width: 320px;">
        <span class="input-group-text">Prefix</span>
        <input id="snap-search-prefix" type="text" class="form-control" placeholder="remote:folder or /abs/prefix" />
      </div>
    </div>
  </div>
  <div id="snap-search-results" class="small" style="margin-top:.25rem"></div>
</section>

<section>
  <h2>Scans Summary</h2>
  <div class="table-responsive" style="max-height:280px; overflow:auto; border:1px solid #eee">
    <table class="table table-sm" style="margin-bottom:0">
      <thead><tr>
        <th>ID</th><th>Path</th><th>Files</th><th>Recursive</th><th>Started</th><th>Ended</th><th>Committed</th>
      </tr></thead>
      <tbody id="scans-summary"></tbody>
    </table>
  </div>
</section>
<section>
  <h2>Start Background Scan</h2>
  <form id="bg-scan-form" class="row g-2">
    <div class="col-auto">
      <label for="scan-path" class="form-label small" style="margin-bottom:.25rem">Path</label>
      <div class="input-group input-group-sm" style="width: 420px;">
        <input id="scan-path" type="text" class="form-control" placeholder="/path/to/scan or remote:sub/path" />
        <button id="bg-use-current" type="button" class="btn btn-outline-secondary">Use current folder</button>
      </div>
    </div>
    <div class="col-auto form-check" style="padding-top:1.8rem">
      <input id="scan-recursive" class="form-check-input" type="checkbox" checked />
      <label class="form-check-label small" for="scan-recursive">Recursive</label>
    </div>
    <div class="col-auto" style="padding-top:1.4rem">
      <button type="submit" class="btn btn-sm btn-primary">Start Scan</button>
    </div>
  </form>
  <div id="tasks-list" style="margin-top:.75rem"></div>

  <div class="actions" style="margin-top:1rem; align-items: baseline; gap: .5rem;">
    <label class="small" for="recent-scans">Recent scans:</label>
    <select id="recent-scans">
      <option value="">-- select --</option>
      {% for s in recent_scans or [] %}
        <option value="{{ s.id }}">{{ s.path }} — {{ s.file_count }} files — {{ '%.0f'|format((s.ended or s.started) or 0) }}</option>
      {% endfor %}
    </select>
    <button id="open-scan" type="button" class="btn btn-sm btn-outline-primary">Open</button>
    <button id="refresh-scans" type="button" class="btn btn-sm btn-outline-secondary">Refresh</button>
    {% if selected_scan %}
      <span class="small">Filtering by scan <code>{{ selected_scan.id }}</code> for <code>{{ selected_scan.path }}</code> (recursive: {{ selected_scan.recursive }}) — <a href="/datasets">Clear filter</a></span>
    {% endif %}
  </div>

  <div id="neo4j-status" class="small" style="margin-top:.5rem; display:flex; align-items:center; gap:.5rem">
    <div id="neo4j-light-files" title="Disconnected" style="width:10px; height:10px; border-radius:50%; background:#000; border:1px solid #333;"></div>
    <span id="neo4j-status-text-files">Neo4j: Not connected</span>
  </div>
  <div id="scans-panel" style="margin-top:0.5rem"></div>

  {% if directories %}
    <details style="margin-top:.5rem;">
      <summary class="small">Previously scanned sources (this session)</summary>
      <ul>
        {% for d in directories %}
          <li>{% if d.provider_id %}<span class="badge">{{ d.provider_id }}</span> {% endif %}<code>{{ d.path }}</code> — files: {{ d.scanned }}, recursive: {{ d.recursive }}{% if d.source %} — <span class="badge">{{ d.source }}</span>{% endif %}</li>
        {% endfor %}
      </ul>
    </details>
  {% endif %}
</section>

{% endblock %}
{% block head %}
<script>
  window.addEventListener('DOMContentLoaded', () => {
    // Provider-aware browser
    const provSelect = document.getElementById('prov-select');
    const rootSelect = document.getElementById('root-select');
    const provGoBtn = document.getElementById('prov-go');
    const provPathInput = document.getElementById('prov-path');
    const provList = document.getElementById('prov-list');
    const provCrumb = document.getElementById('prov-crumb');
    const provPanel = document.getElementById('prov-panel-content');
    const provScanForm = document.getElementById('prov-scan-form');
    const provScanMsg = document.getElementById('prov-scan-msg');
    const btnROC = document.getElementById('open-rocrate');
    const btnROCClose = document.getElementById('close-rocrate');
    const rocFrame = document.getElementById('rocrate-frame');
    const rocMsg = document.getElementById('rocrate-msg');
    let currentProv = null;
    let currentRoot = null;
    let currentPath = null;

    function fmtBytes(n){ if(!n) return ''; const s=['B','KB','MB','GB','TB']; let i=0; let v=n; while(v>=1024 && i<s.length-1){ v/=1024; i++; } return (Math.round(v*10)/10)+' '+s[i]; }
    function fmtTime(ts){ try { return new Date(ts*1000).toLocaleString(); } catch(e){ return String(ts); } }

    async function loadProviders(){
      try {
        const r = await fetch('/api/providers');
        const items = await r.json();
        provSelect.innerHTML = items.map(p => `<option value="${p.id}">${p.display_name}</option>`).join('');
        currentProv = items[0]?.id || 'local_fs';
        provSelect.value = currentProv;
        await loadRoots(currentProv);
      } catch(e){ provSelect.innerHTML = '<option>(failed)</option>'; }
    }

    async function loadRoots(providerId){
      try {
        const r = await fetch('/api/provider_roots?provider_id=' + encodeURIComponent(providerId));
        const roots = await r.json();
        if (!Array.isArray(roots)) { rootSelect.innerHTML = '<option>(none)</option>'; return; }
        rootSelect.innerHTML = roots.map(rt => `<option value="${rt.id}">${rt.name||rt.path||rt.id}</option>`).join('');
        currentRoot = roots[0]?.id || '/';
        rootSelect.value = currentRoot;
        // Reset current path and input: for rclone, use relative (empty)
        if (providerId === 'rclone') {
          currentPath = '';
          if (provPathInput) provPathInput.value = '';
          // Auto-browse rclone root immediately
          await browse(providerId, currentRoot, '');
        } else {
          currentPath = currentRoot;
          if (provPathInput) provPathInput.value = currentPath;
          // Auto-browse non-rclone root immediately
          await browse(providerId, currentRoot, currentPath);
        }
      } catch(e){ rootSelect.innerHTML = '<option>(failed)</option>'; }
    }

    function composePath(providerId, rootId, relOrAbs){
      if (providerId === 'rclone'){
        const remote = (rootId||'').endsWith(':') ? (rootId||'') : ((rootId||'') + ':');
        let rel = (relOrAbs||'').replace(/^\/+/, '');
        // If user pasted the remote prefix into the relative input, strip it
        if (rel && rel.startsWith(remote)) {
          rel = rel.slice(remote.length);
        }
        // Also strip any other "<name>:" prefix they might have pasted
        const colonIdx = rel.indexOf(':');
        if (colonIdx > 0) {
          rel = rel.slice(colonIdx + 1).replace(/^\/+/, '');
        }
        return rel ? (remote + rel) : remote;
      }
      return relOrAbs || rootId || '/';
    }

    function displayPathFor(providerId, rootId, relOrAbs){
      if (providerId === 'rclone'){
        return (relOrAbs||'');
      }
      return relOrAbs || rootId || '/';
    }

    async function browse(providerId, rootId, path){
      const fullPath = composePath(providerId||'local_fs', rootId||'/', path||'');
      const qs = new URLSearchParams({ provider_id: providerId||'local_fs', root_id: rootId||'/', path: fullPath });
      // Append rclone-specific browse options if selected
      if ((providerId||'') === 'rclone'){
        try {
          const chkRec = document.getElementById('prov-browse-recursive');
          const chkFast = document.getElementById('prov-browse-fast-list');
          const inpDepth = document.getElementById('prov-browse-max-depth');
          if (chkRec && chkRec.checked) qs.set('recursive', 'true');
          const d = Number(inpDepth && inpDepth.value ? inpDepth.value : '1');
          if (d && d !== 1) qs.set('max_depth', String(d));
          if (chkFast && chkFast.checked) qs.set('fast_list', 'true');
        } catch(_) { /* ignore UI options if missing */ }
      }
      try {
        const r = await fetch('/api/browse?' + qs.toString());
        const j = await r.json();
        // display breadcrumb: for rclone show Root→Remote and relative path
        const disp = displayPathFor(providerId||'local_fs', rootId||'/', path||'');
        const label = (providerId==='rclone') ? `${(rootId||'').replace(/:$/,'')} → ${disp||'(root)'}` : (fullPath||'/');
        provCrumb.innerHTML = `<span class="small">Path: <code>${label}</code></span>`;
        // Sync input to relative path for rclone; absolute otherwise
        currentPath = disp;
        if (provPathInput) provPathInput.value = currentPath;
        const rows = (j.entries||[]).map(e => {
          const type = e.type === 'folder' ? 'Folder' : 'File';
          const size = e.type === 'folder' ? '' : fmtBytes(e.size||0);
          const mod = fmtTime(e.mtime||0);
          const prov = providerId;
          const chkId = `sel-${btoa((e.id||'')+':'+(e.type||''))}`;
          return `<tr class="prov-item" data-id="${e.id}" data-type="${e.type}">
            <td><input type="checkbox" class="prov-sel" data-id="${e.id}" data-type="${e.type}" /></td>
            <td>${e.name}</td><td>${type}</td><td>${size}</td><td>${mod}</td><td><span class="badge">${prov}</span></td></tr>`;
        }).join('');
        provList.innerHTML = rows || '<tr><td colspan="5" class="small">Empty folder.</td></tr>';
        attachProvHandlers();
      } catch(e){ provList.innerHTML = '<tr><td colspan="5" class="small">Browse failed.</td></tr>'; }
    }

    // Selection store (rules)
    const selectionRules = [];
    function upsertRule(action, path, recursive, node_type){
      // Remove opposite rule if exists, then add/replace
      const idx = selectionRules.findIndex(r => r.path===path && r.recursive===!!recursive && r.node_type===node_type);
      if (idx >= 0) selectionRules.splice(idx,1);
      selectionRules.push({ action, path, recursive: !!recursive, node_type });
      renderSelSummary();
    }
    function renderSelSummary(){
      const s = document.getElementById('sel-summary');
      if (!s) return;
      const inc = selectionRules.filter(r=>r.action==='include').length;
      const exc = selectionRules.filter(r=>r.action==='exclude').length;
      s.textContent = `Selection: ${inc} include, ${exc} exclude`;
    }

    function attachProvHandlers(){
      // Select/Deselect all on page
      const selAll = document.getElementById('prov-sel-all');
      if (selAll){
        selAll.addEventListener('change', () => {
          const boxes = document.querySelectorAll('input.prov-sel');
          boxes.forEach(chk => {
            const was = chk.checked;
            chk.checked = selAll.checked;
            if (was !== selAll.checked){
              // trigger change handler to update rules
              chk.dispatchEvent(new Event('change'));
            }
          });
        });
      }
      // Row click navigates into folders; file shows details
      document.querySelectorAll('tr.prov-item')?.forEach(tr => {
        tr.addEventListener('click', (ev) => {
          // Ignore clicks originating from checkbox
          if (ev.target && ev.target.closest && ev.target.closest('input.prov-sel')) return;
          const id = tr.getAttribute('data-id');
          const type = tr.getAttribute('data-type');
          if (type === 'folder'){
            if (currentProv === 'rclone'){
              const i = id.indexOf(':');
              let rel = i >= 0 ? id.slice(i+1) : id;
              rel = (rel||'').replace(/^\/+/, '');
              currentPath = rel;
            } else {
              currentPath = id;
            }
            if (provPathInput) provPathInput.value = currentPath;
            browse(currentProv, currentRoot, currentPath);
          } else {
            provPanel.innerHTML = `<div><strong>${tr.children[1]?.textContent||id}</strong></div><div class=\"small\">Path: <code>${id}</code></div>`;
          }
        });
      });
      // Checkbox selection → translate to include/exclude rules
      document.querySelectorAll('input.prov-sel')?.forEach(chk => {
        chk.addEventListener('change', () => {
          const id = chk.getAttribute('data-id');
          const type = chk.getAttribute('data-type');
          const isFolder = (type === 'folder');
          const recursive = isFolder;
          const node_type = isFolder ? 'folder' : 'file';
          const action = chk.checked ? 'include' : 'exclude';
          upsertRule(action, id, recursive, node_type);
        });
      });
      renderSelSummary();
    }

    if (provSelect){
      provSelect.addEventListener('change', async () => {
        currentProv = provSelect.value;
        await loadRoots(currentProv); // auto-browse happens in loadRoots
      });
    }
    if (rootSelect){
      rootSelect.addEventListener('change', () => {
        currentRoot = rootSelect.value;
        if (currentProv==='rclone'){
          currentPath='';
          if (provPathInput) provPathInput.value='';
          browse(currentProv, currentRoot, '');
        } else {
          currentPath = currentRoot;
          if (provPathInput) provPathInput.value = currentPath;
          browse(currentProv, currentRoot, currentPath);
        }
      });
    }
    if (btnROC && rocFrame){
      btnROC.addEventListener('click', () => {
        const provId = (provSelect && provSelect.value) || currentProv || 'local_fs';
        const rootId = (rootSelect && rootSelect.value) || currentRoot || '/';
        const path = (provPathInput && provPathInput.value) || currentPath || rootId || '/';
        const qs = new URLSearchParams({ provider_id: provId, root_id: rootId, path });
        rocFrame.src = '/rocrate_view?' + qs.toString();
        rocFrame.style.display = 'block';
        if (btnROCClose) btnROCClose.style.display = 'inline-block';
        if (rocMsg) rocMsg.textContent = 'Loading…';
        rocFrame.onload = () => { if (rocMsg) rocMsg.textContent = ''; };
      });
    }
    if (btnROCClose && rocFrame){
      btnROCClose.addEventListener('click', () => {
        rocFrame.style.display = 'none';
        rocFrame.src = '';
        if (btnROCClose) btnROCClose.style.display = 'none';
        if (rocMsg) rocMsg.textContent = 'Viewer closed.';
      });
    }
    if (provGoBtn){
      const doGo = () => {
        currentProv = provSelect.value; 
        currentRoot = rootSelect.value; 
        let rel = (provPathInput && provPathInput.value) ? provPathInput.value.trim() : (currentPath || '');
        // For rclone, keep empty to mean remote root; do not fallback to rootId string in the input
        if (currentProv === 'rclone' && !rel) rel = '';
        // For non-rclone, fallback to absolute root if empty
        if (currentProv !== 'rclone' && !rel) rel = currentRoot || '/';
        currentPath = rel; 
        browse(currentProv, currentRoot, currentPath);
      };
      provGoBtn.addEventListener('click', (e) => { e.preventDefault(); doGo(); });
      if (provPathInput){ provPathInput.addEventListener('keydown', (e) => { if (e.key === 'Enter'){ e.preventDefault(); doGo(); } }); }
      // Optional: re-browse on option changes for rclone
      const chkRec = document.getElementById('prov-browse-recursive');
      const chkFast = document.getElementById('prov-browse-fast-list');
      const inpDepth = document.getElementById('prov-browse-max-depth');
      const reBrowse = () => { if ((provSelect.value||'')==='rclone'){ doGo(); } };
      if (chkRec) chkRec.addEventListener('change', reBrowse);
      if (chkFast) chkFast.addEventListener('change', reBrowse);
      if (inpDepth) inpDepth.addEventListener('change', reBrowse);
    }
    if (provScanForm){
      provScanForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        // Derive values from UI at submit-time to avoid race with async init
        const provId = (provSelect && provSelect.value) || currentProv || 'local_fs';
        const rootId = (rootSelect && rootSelect.value) || currentRoot || '/';
        const inputPath = (provPathInput && provPathInput.value && provPathInput.value.trim()) || '';
        const relOrAbs = inputPath || currentPath || '';
        // Compose full scan target for Rclone; keep other providers untouched
        let scanPath = relOrAbs || rootId || '/';
        if (provId === 'rclone') {
          scanPath = composePath(provId, rootId, relOrAbs); // e.g., "dropbox:AIPT"
        }
        currentProv = provId;
        currentRoot = rootId;
        currentPath = relOrAbs;
        if (!provId || !scanPath){ provScanMsg.textContent = 'Select a provider and folder first.'; return; }
        const recursive = document.getElementById('prov-scan-recursive').checked;
        const chkFast = document.getElementById('prov-browse-fast-list');
        const fastList = !!(chkFast && chkFast.checked);
        const btn = provScanForm.querySelector('button[type="submit"]');
        if (btn) { btn.disabled = true; btn.textContent = 'Scanning…'; }
        provScanMsg.textContent = `Starting scan for ${scanPath}…`;
        // Add a local pseudo-task so status appears with other progress bars
        const localId = 'provscan-' + Date.now();
        const localTask = { id: localId, type: 'scan', status: 'running', path: scanPath, processed: 0, total: null, progress: 0 };
        try { (window.scidkLocalTasks||[]).push(localTask); } catch(_) { /* ignore */ }
        fetchTasks(); // trigger re-render with local task
        try {
          const overrideIg = !!(document.getElementById('sel-override-ignore') && document.getElementById('sel-override-ignore').checked);
          const selection = { rules: selectionRules.slice(), use_ignore: true, allow_override_ignores: overrideIg };
          const r = await fetch('/api/scan', { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ provider_id: provId, root_id: rootId||'/', path: scanPath, recursive, fast_list: fastList, selection }) });
          const ctype = (r.headers && r.headers.get('content-type')) || '';
          let j = null;
          if (ctype.includes('application/json')){
            try { j = await r.json(); } catch(_) { j = null; }
          } else {
            try { const txt = await r.text(); throw new Error(`HTTP ${r.status}: ${txt}`); } catch(e){ throw e; }
          }
          if (r.ok && j){
            const files = j.scanned || 0;
            const folders = (j.folder_count !== undefined) ? j.folder_count : undefined;
            const dur = j.duration_sec ? (Math.round(j.duration_sec*10)/10+'s') : '';
            let msg = `Scan complete: ${j.scan_id} — files: ${files}`;
            if (folders !== undefined) msg += `, folders: ${folders}`;
            if (files === 0 && folders > 0 && !recursive){ msg += ' — Only folders found. Enable Recursive to include files in subfolders.'; }
            if (dur) msg += ` (${dur})`;
            provScanMsg.textContent = msg;
            localTask.status = 'completed';
            localTask.processed = files;
            localTask.total = files || localTask.processed;
            localTask.progress = 1;
            localTask.scan_id = j.scan_id;
          } else {
            const err = (j && (j.error||j.message)) || `HTTP ${r.status}`;
            provScanMsg.textContent = `Scan error: ${err}`;
            localTask.status = 'error';
            localTask.error = err;
            localTask.progress = 1;
          }
        } catch(err){
          provScanMsg.textContent = 'Scan error: ' + err;
          localTask.status = 'error';
          localTask.error = (err && err.message) ? err.message : String(err);
          localTask.progress = 1;
        }
        finally {
          if (btn) { btn.disabled = false; btn.textContent = 'Scan'; }
          fetchTasks();
        }
      });
    }
    const btnScanWithSel = document.getElementById('btn-scan-with-selection');
    if (btnScanWithSel){ btnScanWithSel.addEventListener('click', (ev) => { ev.preventDefault(); if (provScanForm) provScanForm.dispatchEvent(new Event('submit')); }); }

    // Snapshot browse logic (index-backed)
    const snapScanSel = document.getElementById('snapshot-scan');
    const snapPathInput = document.getElementById('snap-path');
    const snapTypeSel = document.getElementById('snap-type');
    const snapExtInput = document.getElementById('snap-ext');
    const snapPageSize = document.getElementById('snap-page-size');
    const snapGo = document.getElementById('snap-go');
    const snapPrev = document.getElementById('snap-prev');
    const snapNext = document.getElementById('snap-next');
    const snapUseLive = document.getElementById('snap-use-live');
    const snapCommit = document.getElementById('snap-commit');
    const snapReint = document.getElementById('snap-reinterpret');
    const snapRescan = document.getElementById('snap-rescan');
    const snapStatus = document.getElementById('snap-status');
    const snapSearchQ = document.getElementById('snap-search-q');
    const snapSearchExt = document.getElementById('snap-search-ext');
    const snapSearchPrefix = document.getElementById('snap-search-prefix');
    const snapSearchBtn = document.getElementById('snap-search-go');
    const snapSearchResults = document.getElementById('snap-search-results');
    const snapList = document.getElementById('snap-list');
    const snapCrumb = document.getElementById('snap-crumb');
    let snapToken = null;
    let snapHistory = [];
    // cache rclone interpret settings
    let rcSettings = { suggest_mount_threshold: 400, max_files_per_batch: 1000 };
    async function loadRcSettings(){
      try{ const r = await fetch('/api/settings/rclone-interpret'); const j = await r.json(); if (r.ok){ rcSettings = { suggest_mount_threshold: Number(j.suggest_mount_threshold||400), max_files_per_batch: Number(j.max_files_per_batch||1000) }; } }
      catch(_) { /* ignore */ }
    }
    loadRcSettings();
    async function loadScansForSnapshot(){
      try{ const r = await fetch('/api/scans'); const scans = await r.json(); if (!snapScanSel) return; const current = snapScanSel.value; snapScanSel.innerHTML = '<option value="">-- select a recent scan below --</option>' + scans.map(s => `<option value="${s.id}">${s.path} — ${s.file_count} files</option>`).join(''); if (current) snapScanSel.value = current; } catch(e) { /* ignore */ }
      // show/hide rclone banner if applicable
      try {
        const id = snapScanSel && snapScanSel.value;
        const banner = document.getElementById('rclone-banner');
        if (id){ const rs = await fetch(`/api/scans/${encodeURIComponent(id)}`); const scan = await rs.json(); const isRclone = (scan && scan.provider_id) === 'rclone'; const big = (scan && (scan.file_count||0)) >= (rcSettings.suggest_mount_threshold||400); if (banner) banner.style.display = (isRclone && big) ? '' : 'none'; }
        else { if (banner) banner.style.display = 'none'; }
      } catch(_) { /* ignore */ }
    }
    async function browseSnapshot(direction){
      if (!snapScanSel || !snapScanSel.value){ snapList.innerHTML = '<tr><td colspan="4" class="small">Select a scan first.</td></tr>'; return; }
      const scanId = snapScanSel.value;
      const path = (snapPathInput && snapPathInput.value.trim()) || '';
      const type = (snapTypeSel && snapTypeSel.value) || '';
      const ext = (snapExtInput && snapExtInput.value.trim()) || '';
      const ps = Number((snapPageSize && snapPageSize.value) || '100') || 100;
      const qs = new URLSearchParams({ page_size: String(ps) });
      if (path !== '') qs.set('path', path);
      if (type) qs.set('type', type);
      if (ext) qs.set('extension', ext.toLowerCase());
      if (direction === 'next' && snapToken) qs.set('next_page_token', snapToken);
      if (direction === 'prev'){
        // naive prev: step back one page using history
        if (snapHistory.length >= 2){ snapHistory.pop(); const prevTok = snapHistory.pop(); if (prevTok) qs.set('next_page_token', prevTok); else qs.delete('next_page_token'); }
      }
      try{
        const r = await fetch(`/api/scans/${encodeURIComponent(scanId)}/browse?` + qs.toString());
        const j = await r.json();
        if (!r.ok){ snapList.innerHTML = `<tr><td colspan="4" class="small">Error: ${j.error||r.status}</td></tr>`; return; }
        const entries = j.entries||[];
        snapToken = j.next_page_token || null;
        if (direction !== 'prev') snapHistory.push(j.next_page_token || '');
        // Update crumb with clickable ancestors
        const p = j.path || '';
        let parts = [];
        const panel = document.getElementById('snap-panel');
        if (panel) { panel.style.display = 'none'; panel.innerHTML=''; }
        if (p){
          if (p.includes(':')){ const i = p.indexOf(':'); const rem = p.slice(0,i+1); const suff = p.slice(i+1).replace(/^\/+/, ''); const segs = suff? suff.split('/'): []; let acc = rem; parts.push({name: rem.replace(/:$/,''), path: rem}); for (let s of segs){ acc = acc + (acc.endsWith(':')? '':'/') + s; parts.push({name: s, path: acc}); }
          } else { const segs = p.replace(/^\/+/, '').split('/'); let acc = ''; for (let i=0;i<segs.length;i++){ acc = (i===0? ('/'+segs[i]) : (acc + '/' + segs[i])); parts.push({name: segs[i]||'/', path: acc}); } }
        }
        const crumbHtml = parts.length? parts.map((c, idx) => `<a href="#" data-snap-path="${c.path}">${c.name||'/'}</a>`).join(' / ') : '(scan root)';
        snapCrumb.innerHTML = `<span class="small">Scan <code>${scanId}</code> — Path: ${crumbHtml} — Showing ${entries.length}${snapToken?(' (next token '+snapToken+')'):''}</span>`;
        // attach crumb handlers
        snapCrumb.querySelectorAll('a[data-snap-path]')?.forEach(a => {
          a.addEventListener('click', (ev) => { ev.preventDefault(); const np = a.getAttribute('data-snap-path'); if (snapPathInput){ snapPathInput.value = np||''; snapToken=null; snapHistory=[]; browseSnapshot(); } });
        });
        // Render
        const rows = entries.map(e => {
          const mod = (e.modified && e.modified > 0 && e.type==='file') ? fmtTime(e.modified) : '';
          const interp = e.interpreted_as ? `<span class=\"badge\">${e.interpreted_as}</span>` : '';
          const esc = (s) => (s||'').replaceAll('&','&amp;').replaceAll('"','&quot;').replaceAll('<','&lt;').replaceAll('>','&gt;');
          const preview = e.interpretation_json ? esc((e.interpretation_json||'').slice(0,800)) : '';
          return `<tr data-path="${e.path}" data-type="${e.type}" data-interp-as="${e.interpreted_as||''}" data-interp-json="${preview}"><td>${e.name} ${interp}</td><td>${e.type}</td><td>${e.type==='file'?(fmtBytes(e.size||0)):''}</td><td>${mod}</td></tr>`;
        }).join('');
        snapList.innerHTML = rows || '<tr><td colspan="4" class="small">No entries.</td></tr>';
        snapNext.disabled = !snapToken;
        snapPrev.disabled = (snapHistory.length <= 1);
        // Click to drill when folder; show details when file
        document.querySelectorAll('#snap-list tr')?.forEach(tr => {
          tr.addEventListener('click', () => {
            const t = tr.getAttribute('data-type'); const p = tr.getAttribute('data-path');
            const panel = document.getElementById('snap-panel');
            if (t === 'folder' && snapPathInput){ snapPathInput.value = p; snapToken = null; snapHistory = []; browseSnapshot(); return; }
            if (t === 'file' && panel){
              const ias = tr.getAttribute('data-interp-as') || '';
              const ij = tr.getAttribute('data-interp-json') || '';
              let body = '';
              if (ias){ body += `<div>Interpreted as: <span class=\"badge\">${ias}</span></div>`; }
              if (ij){
                try {
                  const parsed = JSON.parse(ij);
                  body += `<details open style=\"margin-top:.25rem\"><summary class=\"small\">Interpretation</summary><pre style=\"white-space: pre-wrap;\">${JSON.stringify(parsed, null, 2)}</pre></details>`;
                } catch(_){ body += `<details open style=\"margin-top:.25rem\"><summary class=\"small\">Interpretation</summary><pre style=\"white-space: pre-wrap;\">${ij}</pre></details>`; }
              } else {
                body += '<div class="small">No interpretation stored for this file.</div>';
              }
              panel.innerHTML = `<div><strong>Path:</strong> <code>${p}</code></div>${body}`;
              panel.style.display = 'block';
            }
          });
        });
      } catch(e){
        snapList.innerHTML = `<tr><td colspan="4" class="small">Browse failed.</td></tr>`;
      }
    }
    if (snapGo){ snapGo.addEventListener('click', () => { snapToken = null; snapHistory = []; browseSnapshot(); }); }
    if (snapNext){ snapNext.addEventListener('click', () => browseSnapshot('next')); }
    if (snapPrev){ snapPrev.addEventListener('click', () => browseSnapshot('prev')); }
    if (snapSearchBtn){ snapSearchBtn.addEventListener('click', async () => {
      if (!snapScanSel || !snapScanSel.value){ snapSearchResults.textContent = 'Select a scan first.'; return; }
      const qs = new URLSearchParams();
      const q = (snapSearchQ && snapSearchQ.value.trim()) || '';
      const ext = (snapSearchExt && snapSearchExt.value.trim()) || '';
      const prefix = (snapSearchPrefix && snapSearchPrefix.value.trim()) || '';
      if (q) qs.set('q', q);
      if (ext) qs.set('ext', ext);
      if (prefix) qs.set('prefix', prefix);
      qs.set('scan_id', snapScanSel.value);
      try{
        const r = await fetch('/api/index/search?' + qs.toString());
        const j = await r.json();
        if (!r.ok){ snapSearchResults.textContent = 'Search error: ' + (j.error||r.status); return; }
        const rows = (j.results||[]).map(it => `<div><code>${it.path}</code> — ${it.ext||''} ${it.size?('('+fmtBytes(it.size)+')'):''}</div>`).join('');
        snapSearchResults.innerHTML = rows || '<div class="small">No matches.</div>';
      } catch(e){ snapSearchResults.textContent = 'Search error: ' + e; }
    }); }
    if (snapScanSel){ snapScanSel.addEventListener('change', () => { snapToken = null; snapHistory = []; browseSnapshot(); loadScansForSnapshot(); }); }
    if (snapUseLive){ snapUseLive.addEventListener('click', () => {
      const provId = (provSelect && provSelect.value) || currentProv || 'local_fs';
      const rootId = (rootSelect && rootSelect.value) || currentRoot || '/';
      const relOrAbs = (provPathInput && provPathInput.value && provPathInput.value.trim()) || currentPath || '';
      const full = provId === 'rclone' ? composePath(provId, rootId, relOrAbs) : (relOrAbs || rootId || '/');
      if (snapPathInput) snapPathInput.value = full;
    }); }
    if (snapCommit){ snapCommit.addEventListener('click', async () => {
      if (!snapScanSel || !snapScanSel.value){ snapStatus.textContent = 'Select a scan first.'; return; }
      const id = snapScanSel.value; snapCommit.disabled = true; const prev = snapCommit.textContent; snapCommit.textContent = 'Committing…'; snapStatus.textContent = '';
      try{ const r = await fetch('/api/tasks', { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ type: 'commit', scan_id: id }) }); if (r.status === 202){ snapStatus.textContent = 'Commit started in background. Watch progress above.'; } else { const j = await r.json(); snapStatus.textContent = 'Commit failed: ' + (j.error || r.status); } }
      catch(e){ snapStatus.textContent = 'Commit failed: ' + e; }
      finally { snapCommit.disabled = false; snapCommit.textContent = prev; }
    }); }
    if (snapRescan){ snapRescan.addEventListener('click', async () => {
      if (!snapScanSel || !snapScanSel.value){ snapStatus.textContent = 'Select a scan first.'; return; }
      const id = snapScanSel.value; snapRescan.disabled = true; const prev = snapRescan.textContent; snapRescan.textContent = 'Rescanning…'; snapStatus.textContent = '';
      try{
        const r = await fetch(`/api/scans/${encodeURIComponent(id)}/rescan`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({}) });
        const j = await r.json();
        if (!r.ok){ snapStatus.textContent = 'Rescan failed: ' + (j.error || r.status); }
        else { snapStatus.textContent = `Rescan started: ${j.scan_id}`; loadScansForSnapshot(); }
      } catch(e){ snapStatus.textContent = 'Rescan failed: ' + e; }
      finally { snapRescan.disabled = false; snapRescan.textContent = prev; }
    }); }

    if (snapReint){ snapReint.addEventListener('click', async () => {
      if (!snapScanSel || !snapScanSel.value){ snapStatus.textContent = 'Select a scan first.'; return; }
      const id = snapScanSel.value; snapReint.disabled = true; const prev = snapReint.textContent; snapReint.textContent = 'Re-interpreting…'; snapStatus.textContent = '';
      try{
        // Fetch scan details to decide which endpoint to call
        const sd = await fetch(`/api/scans/${encodeURIComponent(id)}`);
        const scan = await sd.json();
        const providerId = (scan && scan.provider_id) || null;
        if (providerId === 'rclone'){
          // Chunked streaming interpretation for rclone scans
          const batch = rcSettings.max_files_per_batch || 1000;
          let cursor = null;
          let totalProcessed = 0, totalErrors = 0, batches = 0;
          const common = { include: ["*.txt","*.csv","*.md","*.json","*.yaml","*.yml","*.py","*.ipynb"], max_files: batch, max_size_bytes: 1048576, timeout_sec: 60, overwrite: true };
          while (true){
            const payload = cursor ? { ...common, after_rowid: cursor } : { ...common };
            const r = await fetch(`/api/interpret/scan/${encodeURIComponent(id)}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            const j = await r.json();
            if (!r.ok){ snapStatus.textContent = 'Interpret (remote) failed: ' + (j.error || r.status); break; }
            totalProcessed += (j.processed_count||0); totalErrors += (j.error_count||0); batches += 1;
            snapStatus.textContent = `Interpret (remote): batches=${batches}, processed=${totalProcessed}, errors=${totalErrors}`;
            if (!j.next_cursor){ break; }
            cursor = j.next_cursor;
          }
          browseSnapshot();
        } else {
          // Legacy local reinterpret
          const r = await fetch(`/api/scans/${encodeURIComponent(id)}/reinterpret`, { method: 'POST' });
          const j = await r.json();
          if (!r.ok){ snapStatus.textContent = 'Re-interpret failed: ' + (j.error || r.status); }
          else {
            const fs = (j.files_seen!==undefined)?`, files_seen=${j.files_seen}`:''; const fm = (j.files_matched!==undefined)?`, files_matched=${j.files_matched}`:'';
            snapStatus.textContent = `Re-interpret: updated=${j.updated}, skipped_remote=${j.skipped_remote}, not_found=${j.not_found}, errors=${j.errors}${fs}${fm}`;
            browseSnapshot();
          }
        }
      }
      catch(e){ snapStatus.textContent = 'Re-interpret failed: ' + e; }
      finally { snapReint.disabled = false; snapReint.textContent = prev; }
    }); }

    // Scans dropdown and background tasks
    // Recent scans dropdown helpers
    const select = document.getElementById('recent-scans');
    const btnOpen = document.getElementById('open-scan');
    const refreshBtn = document.getElementById('refresh-scans');
    function openSelected(){ const id = select && select.value; if (id) { window.location = '/datasets?scan_id=' + encodeURIComponent(id); } }
    if (select && btnOpen) {
      btnOpen.addEventListener('click', openSelected);
      select.addEventListener('change', openSelected);
    }
    async function loadScansIntoDropdown(){
      try {
        const r = await fetch('/api/scans');
        const scans = await r.json();
        if (!select) return;
        const current = select.value;
        select.innerHTML = '<option value="">-- select --</option>' + scans.map(s => `<option value="${s.id}">${s.path} — ${s.file_count} files — ${Math.round(s.ended||s.started||0)}</option>`).join('');
        if (current) select.value = current;
      } catch(e) { /* ignore */ }
    }
    if (refreshBtn) refreshBtn.addEventListener('click', loadScansIntoDropdown);

    const scanForm = document.getElementById('bg-scan-form');
    const tasksDiv = document.getElementById('tasks-list');
    const bgUseCurrent = document.getElementById('bg-use-current');
    if (bgUseCurrent) {
      bgUseCurrent.addEventListener('click', () => {
        const provId = (provSelect && provSelect.value) || currentProv || 'local_fs';
        const rootId = (rootSelect && rootSelect.value) || currentRoot || '/';
        const relOrAbs = (provPathInput && provPathInput.value && provPathInput.value.trim()) || currentPath || '';
        const full = provId === 'rclone' ? composePath(provId, rootId, relOrAbs) : (relOrAbs || rootId || '/');
        const bgInput = document.getElementById('scan-path');
        if (bgInput) bgInput.value = full;
      });
    }
    // Keep a small client-side list for local (synchronous) scans so they appear alongside server tasks
    window.scidkLocalTasks = window.scidkLocalTasks || [];
    const fmtPct = (x) => Math.round((x || 0) * 100);
    function renderTasks(tasks){
      if (!tasks || tasks.length === 0){ tasksDiv.innerHTML = '<p class="small">No background tasks.</p>'; return; }
      tasksDiv.innerHTML = tasks.map(t => {
        const total = (t.total===null||t.total===undefined) ? '?' : (t.total||0);
        const pct = fmtPct(t.progress);
        const bar = `<div style=\"width:100%; background:#eee; height:10px; border-radius:4px; overflow:hidden\"><div style=\"width:${pct}%; height:10px; background:${t.status==='completed'?'#4caf50':(t.status==='error'?'#e53935':'#2196f3')}\"></div></div>`;
        let extra = '';
        if (t.type === 'commit'){
          const attempted = t.neo4j_attempted ? 'yes' : 'no';
          const written = (t.neo4j_written===undefined||t.neo4j_written===null) ? '' : String(t.neo4j_written);
          const dbv = (t.neo4j_db_verified===undefined) ? '' : (t.neo4j_db_verified ? 'ok' : 'fail');
          const dbf = (t.neo4j_db_files||0);
          const dbfo = (t.neo4j_db_folders||0);
          const err = t.neo4j_error ? (` — error: ${t.neo4j_error}`) : '';
          extra = `<div class=\"small\">Neo4j: attempted=${attempted}${written!==''?(' — prepared='+written):''}${dbv!==''?(' — verify='+dbv+' (files:'+dbf+', folders:'+dbfo+')'):''}${err}</div>`;
        }
        const cancelBtn = (t.status==='running') ? ` <button class=\"btn btn-sm btn-outline-danger\" data-cancel=\"${t.id}\">Cancel</button>` : '';
        const info = `<div class=\"small\">${t.type} ${t.status} — ${t.path || ''} — ${t.processed||0}/${total} (${pct}%) ${t.error?(' — error: '+t.error):''} ${t.scan_id?(' — <a href=\"/datasets?scan_id='+t.scan_id+'\">open</a>'):''} ${cancelBtn}</div>`;
        return `<div style=\"margin:.25rem 0\">${bar}${info}${extra}</div>`;
      }).join('');
      // Attach cancel handlers
      tasksDiv.querySelectorAll('button[data-cancel]')?.forEach(btn => {
        btn.addEventListener('click', async () => {
          const id = btn.getAttribute('data-cancel');
          try {
            const r = await fetch('/api/tasks/' + encodeURIComponent(id) + '/cancel', { method: 'POST' });
            if (!r.ok) {
              try { const j = await r.json(); alert('Cancel failed: ' + (j.error || r.status)); }
              catch(_) { alert('Cancel failed: ' + r.status); }
            }
          } catch (e) {
            alert('Cancel failed: ' + e);
          } finally {
            try { fetchTasks(); } catch(_) { /* ignore */ }
          }
        });
      });
    }
    async function fetchTasks(){
      try { const r = await fetch('/api/tasks'); const data = await r.json(); const all = ([]).concat(Array.isArray(data)?data:[]).concat(window.scidkLocalTasks||[]); renderTasks(all); }
      catch(e){ /* ignore */ }
    }
    let poller = null;
    async function fetchNeoStatus(){
      try {
        const r = await fetch('/api/settings/neo4j');
        const j = await r.json();
        const light = document.getElementById('neo4j-light-files');
        const txt = document.getElementById('neo4j-status-text-files');
        const ok = !!(j && j.connected);
        if (light) { light.style.background = ok ? '#19c37d' : '#000'; light.title = ok ? 'Connected' : 'Disconnected'; }
        if (txt) { txt.textContent = ok ? 'Neo4j: Connected' : (j && j.last_error ? ('Neo4j: Error — ' + j.last_error) : 'Neo4j: Not connected'); }
      } catch(e) {
        const txt = document.getElementById('neo4j-status-text-files');
        if (txt) txt.textContent = 'Neo4j: status unavailable';
      }
    }
    function renderScansSummaryRows(scans){
      const tbody = document.getElementById('scans-summary');
      if (!tbody) return;
      const fmtTs = (t) => { try { return t ? new Date(Math.round(t)*1000).toLocaleString() : ''; } catch(_) { return t || ''; } };
      if (!scans || scans.length === 0){ tbody.innerHTML = '<tr><td colspan="7" class="small">No scans yet.</td></tr>'; return; }
      tbody.innerHTML = scans.map(s => `<tr>
        <td><code>${s.id}</code></td>
        <td>${s.path}</td>
        <td>${s.file_count||0}</td>
        <td>${s.recursive?'yes':'no'}</td>
        <td>${fmtTs(s.started)}</td>
        <td>${fmtTs(s.ended)}</td>
        <td>${s.committed?'yes':'no'}</td>
      </tr>`).join('');
    }
    async function startPolling(){
      if (poller) return;
      poller = setInterval(async () => {
        try {
          const r = await fetch('/api/scans');
          const scans = await r.json();
          renderScansSummaryRows(scans);
        } catch(e){ /* ignore */ }
        fetchTasks();
        loadScansIntoDropdown();
        loadScansForSnapshot();
        renderScansPanel();
        fetchNeoStatus();
      }, 1000);
    }
    function stopPolling(){ if (poller){ clearInterval(poller); poller = null; } }
    if (scanForm){
      scanForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const path = document.getElementById('scan-path').value.trim();
        const recursive = document.getElementById('scan-recursive').checked;
        try {
          const provId = (provSelect && provSelect.value) || currentProv || 'local_fs';
          const rootId = (rootSelect && rootSelect.value) || currentRoot || '/';
          const overrideIgSel = !!(document.getElementById('sel-override-ignore') && document.getElementById('sel-override-ignore').checked);
                    const selection = { rules: selectionRules.slice(), use_ignore: true, allow_override_ignores: overrideIgSel };
                    const payload = { type: 'scan', path, recursive, provider_id: provId, root_id: rootId, selection };
          const r = await fetch('/api/tasks', { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify(payload) });
          if (r.status === 202){ startPolling(); fetchTasks(); }
          else { const j = await r.json(); alert('Task error: ' + (j.error || r.status)); }
        } catch(err){ alert('Task error: ' + err); }
      });
      // initial render
      startPolling(); fetchTasks(); loadScansIntoDropdown(); fetchNeoStatus();
    }

    // Scans management panel
    const scansDiv = document.getElementById('scans-panel');
    function scansRow(s){
      const ts = Math.round(s.ended||s.started||0);
      return `<div style="padding:.25rem 0; border-bottom:1px solid #eee; display:flex; gap:.5rem; align-items:center; justify-content:space-between">
        <div class="small"><code>${s.id}</code> — ${s.path} — files: ${s.file_count} — ${s.recursive?'recursive':'shallow'} — ${ts}</div>
        <div style="display:flex; gap:.5rem">
          <a class="btn btn-sm btn-outline-primary" href="/datasets?scan_id=${s.id}">Open</a>
          <button class="btn btn-sm btn-outline-success" data-scan="${s.id}" data-action="commit">Commit to Graph</button>
          <button class="btn btn-sm btn-outline-warning" data-scan="${s.id}" data-action="rescan">Rescan</button>
          <button class="btn btn-sm btn-outline-danger" data-scan="${s.id}" data-action="delete">Delete</button>
        </div>
      </div>`;
    }
    async function renderScansPanel(){
      try { const r = await fetch('/api/scans'); const scans = await r.json(); scansDiv.innerHTML = scans.map(scansRow).join('') || '<p class="small">No scans yet.</p>'; }
      catch(e){ scansDiv.innerHTML = '<p class="small">Failed to load scans.</p>'; }
      // attach handlers
      scansDiv.querySelectorAll('button[data-action]')?.forEach(btn => {
        btn.addEventListener('click', async () => {
          const id = btn.getAttribute('data-scan');
          const action = btn.getAttribute('data-action');
          try {
            if (action === 'commit'){
              // Start background commit task to show progress in the Tasks panel
              const r = await fetch('/api/tasks', { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ type: 'commit', scan_id: id }) })
              if (r.status === 202){
                alert('Commit started in background. Watch progress above.');
                startPolling(); fetchTasks();
              } else {
                const j = await r.json();
                alert('Commit task error: ' + (j.error || r.status));
              }
            } else if (action === 'delete'){
              const r = await fetch('/api/scans/' + encodeURIComponent(id), { method: 'DELETE' });
              if (!r.ok){ const j = await r.json(); alert('Delete failed: ' + (j.error || r.status)); }
            } else if (action === 'rescan'){
              const r = await fetch('/api/scans/' + encodeURIComponent(id) + '/rescan', { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({}) });
              const j = await r.json();
              if (!r.ok){ alert('Rescan failed: ' + (j.error || r.status)); }
              else { alert('Rescan started: ' + (j.scan_id || '(ok)')); }
            }
          } catch(err){ alert('Action failed: ' + err); }
          renderScansPanel();
          loadScansIntoDropdown();
        });
      });
    }
    renderScansPanel();

    // File Browser logic
    // Initialize provider UI
    if (provSelect){ loadProviders(); }
  });
</script>
{% endblock %}