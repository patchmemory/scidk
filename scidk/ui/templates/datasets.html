{% extends 'base.html' %}
{% block title %}SciDK - Files{% endblock %}
{% block content %}
<h1>Files</h1>
<section>
  <h2>Files</h2>
  <div class="row g-2" style="margin-bottom:.5rem">
    <div class="col-auto">
      <label for="prov-select" class="form-label small" style="margin-bottom:.25rem">Provider</label>
      <select id="prov-select" class="form-select form-select-sm" style="min-width:220px"></select>
    </div>
    <div class="col-auto">
      <label for="root-select" id="root-label" class="form-label small" style="margin-bottom:.25rem">Root</label>
      <select id="root-select" class="form-select form-select-sm" style="min-width:240px"></select>
    </div>
    <div class="col-auto">
      <label for="prov-path" class="form-label small" style="margin-bottom:.25rem">Path</label>
      <input id="prov-path" type="text" class="form-control form-control-sm" placeholder="/path/within/root" style="width:360px" />
    </div>
    <div class="col-auto" style="display:flex; gap:.5rem; align-items:end;">
      <button id="prov-go" class="btn btn-sm btn-outline-primary">Go</button>
    </div>
  </div>
  <div id="prov-crumb" class="small" style="margin-bottom:.5rem"></div>
  <div style="display:flex; gap:1rem; align-items:flex-start">
    <div style="flex: 2 1 60%; border:1px solid #eee; max-height:420px; overflow:auto">
      <table class="table table-sm" style="margin-bottom:0">
        <thead><tr><th>Name</th><th>Type</th><th>Size</th><th>Modified</th><th>Provider</th></tr></thead>
        <tbody id="prov-list"></tbody>
      </table>
    </div>
    <div id="prov-panel" style="flex: 1 1 40%; border:1px solid #eee; min-height:200px; padding:.5rem; position:sticky; top:1rem">
      <div class="small" id="prov-panel-content">Select a provider, root, and item to see details.
        <div style="margin-top:.5rem">
          <form id="prov-scan-form" class="row g-2">
            <div class="col-auto small">Scan selected folder (recursive):</div>
            <div class="col-auto form-check">
              <input id="prov-scan-recursive" class="form-check-input" type="checkbox" checked />
              <label class="form-check-label small" for="prov-scan-recursive">Recursive</label>
            </div>
            <div class="col-auto">
              <button type="submit" class="btn btn-sm btn-primary">Scan</button>
            </div>
          </form>
          <div class="small" id="prov-scan-msg" style="margin-top:.25rem"></div>
        </div>
      </div>
    </div>
  </div>
</section>

{% if files_viewer == 'rocrate' %}
<section>
  <h2>RO-Crate Viewer</h2>
  <div class="row g-2" style="margin-bottom:.5rem; align-items: end;">
    <div class="col-auto" style="display:flex; gap:.5rem;">
      <button id="open-rocrate" class="btn btn-sm btn-outline-success">Open in RO-Crate Viewer</button>
      <button id="close-rocrate" class="btn btn-sm btn-outline-secondary" style="display:none">Close RO-Crate Viewer</button>
    </div>
    <div class="col small" id="rocrate-msg"></div>
  </div>
  <iframe id="rocrate-frame" style="width:100%; height:60vh; border:1px solid #ddd; display:none"></iframe>
  <div class="small" style="margin-top:.25rem">This experimental viewer uses a minimal JSON-LD from <code>/api/rocrate</code> (or wrapper). Large folders may be truncated.</div>
</section>
{% else %}
<div class="alert alert-secondary small" role="alert" style="margin-top:.5rem">
  RO-Crate viewer is disabled. Enable it by setting environment variable <code>SCIDK_FILES_VIEWER=rocrate</code>,
  or <a href="/datasets?files_viewer=rocrate">open this page with <code>?files_viewer=rocrate</code></a>.
</div>
{% endif %}

<section>
  <h2>Scans Summary</h2>
  <div class="table-responsive" style="max-height:280px; overflow:auto; border:1px solid #eee">
    <table class="table table-sm" style="margin-bottom:0">
      <thead><tr>
        <th>ID</th><th>Path</th><th>Files</th><th>Recursive</th><th>Started</th><th>Ended</th><th>Committed</th>
      </tr></thead>
      <tbody id="scans-summary"></tbody>
    </table>
  </div>
</section>
<section>
  <h2>Start Background Scan</h2>
  <form id="bg-scan-form" class="row g-2">
    <div class="col-auto">
      <label for="scan-path" class="form-label small" style="margin-bottom:.25rem">Path</label>
      <input id="scan-path" type="text" class="form-control form-control-sm" placeholder="/path/to/scan" style="width:320px" />
    </div>
    <div class="col-auto form-check" style="padding-top:1.8rem">
      <input id="scan-recursive" class="form-check-input" type="checkbox" checked />
      <label class="form-check-label small" for="scan-recursive">Recursive</label>
    </div>
    <div class="col-auto" style="padding-top:1.4rem">
      <button type="submit" class="btn btn-sm btn-primary">Start Scan</button>
    </div>
  </form>
  <div id="tasks-list" style="margin-top:.75rem"></div>

  <div class="actions" style="margin-top:1rem; align-items: baseline; gap: .5rem;">
    <label class="small" for="recent-scans">Recent scans:</label>
    <select id="recent-scans">
      <option value="">-- select --</option>
      {% for s in recent_scans or [] %}
        <option value="{{ s.id }}">{{ s.path }} — {{ s.file_count }} files — {{ '%.0f'|format((s.ended or s.started) or 0) }}</option>
      {% endfor %}
    </select>
    <button id="open-scan" type="button" class="btn btn-sm btn-outline-primary">Open</button>
    <button id="refresh-scans" type="button" class="btn btn-sm btn-outline-secondary">Refresh</button>
    {% if selected_scan %}
      <span class="small">Filtering by scan <code>{{ selected_scan.id }}</code> for <code>{{ selected_scan.path }}</code> (recursive: {{ selected_scan.recursive }}) — <a href="/datasets">Clear filter</a></span>
    {% endif %}
  </div>

  <div id="neo4j-status" class="small" style="margin-top:.5rem; display:flex; align-items:center; gap:.5rem">
    <div id="neo4j-light-files" title="Disconnected" style="width:10px; height:10px; border-radius:50%; background:#000; border:1px solid #333;"></div>
    <span id="neo4j-status-text-files">Neo4j: Not connected</span>
  </div>
  <div id="scans-panel" style="margin-top:0.5rem"></div>

  {% if directories %}
    <details style="margin-top:.5rem;">
      <summary class="small">Previously scanned sources (this session)</summary>
      <ul>
        {% for d in directories %}
          <li>{% if d.provider_id %}<span class="badge">{{ d.provider_id }}</span> {% endif %}<code>{{ d.path }}</code> — files: {{ d.scanned }}, recursive: {{ d.recursive }}{% if d.source %} — <span class="badge">{{ d.source }}</span>{% endif %}</li>
        {% endfor %}
      </ul>
    </details>
  {% endif %}
</section>

{% endblock %}
{% block head %}
<script>
  window.addEventListener('DOMContentLoaded', () => {
    // Provider-aware browser
    const provSelect = document.getElementById('prov-select');
    const rootSelect = document.getElementById('root-select');
    const rootLabel = document.getElementById('root-label');
    const provGoBtn = document.getElementById('prov-go');
    const provPathInput = document.getElementById('prov-path');
    const provList = document.getElementById('prov-list');
    const provCrumb = document.getElementById('prov-crumb');
    const provPanel = document.getElementById('prov-panel-content');
    const provScanForm = document.getElementById('prov-scan-form');
    const provScanMsg = document.getElementById('prov-scan-msg');
    const btnROC = document.getElementById('open-rocrate');
    const btnROCClose = document.getElementById('close-rocrate');
    const rocFrame = document.getElementById('rocrate-frame');
    const rocMsg = document.getElementById('rocrate-msg');
    let currentProv = null;
    let currentRoot = null;
    let currentPath = null;

    function fmtBytes(n){ if(!n) return ''; const s=['B','KB','MB','GB','TB']; let i=0; let v=n; while(v>=1024 && i<s.length-1){ v/=1024; i++; } return (Math.round(v*10)/10)+' '+s[i]; }
    function fmtTime(ts){ try { return new Date(ts*1000).toLocaleString(); } catch(e){ return String(ts); } }

    async function loadProviders(){
      try {
        const r = await fetch('/api/providers');
        const items = await r.json();
        provSelect.innerHTML = items.map(p => `<option value="${p.id}">${p.display_name}</option>`).join('');
        currentProv = items[0]?.id || 'local_fs';
        provSelect.value = currentProv;
        await loadRoots(currentProv);
      } catch(e){ provSelect.innerHTML = '<option>(failed)</option>'; }
    }

    async function loadRoots(providerId){
      try {
        const r = await fetch('/api/provider_roots?provider_id=' + encodeURIComponent(providerId));
        const roots = await r.json();
        if (!Array.isArray(roots)) { rootSelect.innerHTML = '<option>(none)</option>'; return; }
        rootSelect.innerHTML = roots.map(rt => `<option value="${rt.id}">${rt.name||rt.path||rt.id}</option>`).join('');
        currentRoot = roots[0]?.id || '/';
        rootSelect.value = currentRoot;
        // Adjust labels/placeholders for rclone vs others
        if (providerId === 'rclone'){
          if (rootLabel) rootLabel.textContent = 'Remote';
          if (provPathInput){ provPathInput.placeholder = 'folder/sub'; provPathInput.value = ''; }
          currentPath = currentRoot; // full path always composed remote+rel
        } else {
          if (rootLabel) rootLabel.textContent = 'Root';
          if (provPathInput){ provPathInput.placeholder = '/path/within/root'; provPathInput.value = currentRoot; }
          currentPath = currentRoot;
        }
      } catch(e){ rootSelect.innerHTML = '<option>(failed)</option>'; }
    }

    function joinRemotePath(remoteId, rel){
      rel = (rel||'').trim();
      // If user pasted a full remote prefix, strip it
      if (rel.indexOf(':') !== -1 && rel.split(':')[0] + ':' === remoteId){
        rel = rel.split(':').slice(1).join(':');
      }
      rel = rel.replace(/^\/+/, '');
      if (!rel) return remoteId;
      return remoteId.endsWith(':') ? (remoteId + rel) : (remoteId.replace(/\/$/,'') + '/' + rel);
    }
    async function browse(providerId, rootId, path){
      let targetPath = path || rootId || '/';
      if (providerId === 'rclone'){
        // When rclone, keep provPathInput as relative; compose full target for API
        const rel = (provPathInput && provPathInput.value) ? provPathInput.value : (path && path.startsWith(rootId) ? path.slice(rootId.length) : '');
        targetPath = joinRemotePath(rootId, rel||'');
      }
      const qs = new URLSearchParams({ provider_id: providerId||'local_fs', root_id: rootId||'/', path: targetPath });
      try {
        const r = await fetch('/api/browse?' + qs.toString());
        const j = await r.json();
        // no breadcrumb API; show current path (full) and remote when rclone
        const displayPath = targetPath;
        provCrumb.innerHTML = providerId === 'rclone'
          ? `<span class="small">Remote: <code>${rootId}</code> — Path: <code>${(provPathInput&&provPathInput.value)||'' || '(root)'}</code></span>`
          : `<span class="small">Path: <code>${displayPath}</code></span>`;
        // Sync inputs
        currentPath = displayPath;
        if (provPathInput){
          if (providerId === 'rclone'){
            // keep relative in the input
            const rel = displayPath.startsWith(rootId) ? displayPath.slice(rootId.length) : '';
            provPathInput.value = rel;
          } else {
            provPathInput.value = currentPath;
          }
        }
        const rows = (j.entries||[]).map(e => {
          const type = e.type === 'folder' ? 'Folder' : 'File';
          const size = e.type === 'folder' ? '' : fmtBytes(e.size||0);
          const mod = fmtTime(e.mtime||0);
          const prov = providerId;
          return `<tr class="prov-item" data-id="${e.id}" data-type="${e.type}"><td>${e.name}</td><td>${type}</td><td>${size}</td><td>${mod}</td><td><span class="badge">${prov}</span></td></tr>`;
        }).join('');
        provList.innerHTML = rows || '<tr><td colspan="5" class="small">Empty folder.</td></tr>';
        attachProvHandlers();
      } catch(e){ provList.innerHTML = '<tr><td colspan="5" class="small">Browse failed.</td></tr>'; }
    }

    function attachProvHandlers(){
      document.querySelectorAll('tr.prov-item')?.forEach(tr => {
        tr.addEventListener('click', () => {
          const id = tr.getAttribute('data-id');
          const type = tr.getAttribute('data-type');
          if (type === 'folder'){
            currentPath = id;
            if (provPathInput) provPathInput.value = currentPath;
            browse(currentProv, currentRoot, currentPath);
          } else {
            provPanel.innerHTML = `<div><strong>${tr.firstChild?.textContent||id}</strong></div><div class="small">Path: <code>${id}</code></div>`;
          }
        });
      });
    }

    if (provSelect){
      provSelect.addEventListener('change', async () => { currentProv = provSelect.value; await loadRoots(currentProv); provList.innerHTML = ''; provCrumb.innerHTML=''; });
    }
    if (rootSelect){
      rootSelect.addEventListener('change', () => { 
        currentRoot = rootSelect.value; 
        if (currentProv === 'rclone'){
          // keep relative empty when switching remotes
          if (provPathInput) provPathInput.value = '';
          currentPath = currentRoot;
        } else {
          currentPath = currentRoot; if (provPathInput) provPathInput.value = currentPath;
        }
      });
    }
    if (btnROC && rocFrame){
      btnROC.addEventListener('click', () => {
        const provId = (provSelect && provSelect.value) || currentProv || 'local_fs';
        const rootId = (rootSelect && rootSelect.value) || currentRoot || '/';
        const path = (provPathInput && provPathInput.value) || currentPath || rootId || '/';
        const qs = new URLSearchParams({ provider_id: provId, root_id: rootId, path });
        rocFrame.src = '/rocrate_view?' + qs.toString();
        rocFrame.style.display = 'block';
        if (btnROCClose) btnROCClose.style.display = 'inline-block';
        if (rocMsg) rocMsg.textContent = 'Loading…';
        rocFrame.onload = () => { if (rocMsg) rocMsg.textContent = ''; };
      });
    }
    if (btnROCClose && rocFrame){
      btnROCClose.addEventListener('click', () => {
        rocFrame.style.display = 'none';
        rocFrame.src = '';
        if (btnROCClose) btnROCClose.style.display = 'none';
        if (rocMsg) rocMsg.textContent = 'Viewer closed.';
      });
    }
    if (provGoBtn){
      const doGo = () => { 
        currentProv = provSelect.value; 
        currentRoot = rootSelect.value; 
        const raw = (provPathInput && provPathInput.value) ? provPathInput.value : '';
        const target = currentProv === 'rclone' ? joinRemotePath(currentRoot, raw) : (raw || currentRoot);
        currentPath = target || currentRoot; 
        browse(currentProv, currentRoot, currentPath); 
      };
      provGoBtn.addEventListener('click', (e) => { e.preventDefault(); doGo(); });
      if (provPathInput){ provPathInput.addEventListener('keydown', (e) => { if (e.key === 'Enter'){ e.preventDefault(); doGo(); } }); }
    }
    if (provScanForm){
      provScanForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        // Derive values from UI at submit-time to avoid race with async init
        const provId = (provSelect && provSelect.value) || currentProv || 'local_fs';
        const rootId = (rootSelect && rootSelect.value) || currentRoot || '/';
        const inputRel = (provPathInput && provPathInput.value && provPathInput.value.trim()) || '';
        const path = (provId === 'rclone') ? joinRemotePath(rootId, inputRel) : (inputRel || currentPath || rootId || '/');
        currentProv = provId;
        currentRoot = rootId;
        currentPath = path;
        if (!provId || !path){ provScanMsg.textContent = 'Select a provider and folder first.'; return; }
        const recursive = document.getElementById('prov-scan-recursive').checked;
        const btn = provScanForm.querySelector('button[type="submit"]');
        if (btn) { btn.disabled = true; btn.textContent = 'Scanning…'; }
        provScanMsg.textContent = `Starting scan for ${path}…`;
        // If local or mounted providers, use background task API for consistent behavior (progress/cancel)
        const isBgCapable = (provId === 'local_fs' || provId === 'mounted_fs');
        let localTask = null;
        try {
          if (isBgCapable){
            const r = await fetch('/api/tasks', { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ type: 'scan', path, recursive }) });
            if (r.status === 202){
              provScanMsg.textContent = 'Scan started in background. Watch progress above.';
              // Kick polling so the new task appears
              try { if (typeof startPolling === 'function') startPolling(); } catch(_) {}
              fetchTasks();
            } else {
              const j = await r.json();
              provScanMsg.textContent = 'Scan task error: ' + (j.error || r.status);
            }
          } else {
            // For non-local providers, use synchronous provider scan API
            // Add a local pseudo-task so status appears with other progress bars
            const localId = 'provscan-' + Date.now();
            localTask = { id: localId, type: 'scan', status: 'running', path, processed: 0, total: null, progress: 0, local: true };
            try { (window.scidkLocalTasks||[]).push(localTask); } catch(_) { /* ignore */ }
            fetchTasks(); // trigger re-render with local task
            const r = await fetch('/api/scan', { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ provider_id: provId, root_id: rootId||'/', path, recursive }) });
            const j = await r.json();
            if (r.ok){
              provScanMsg.textContent = `Scan complete: ${j.scan_id} — ${j.scanned} files (${j.duration_sec ? (Math.round(j.duration_sec*10)/10+'s') : ''})`;
              // Mark local task completed
              localTask.status = 'completed';
              localTask.processed = j.scanned || 0;
              localTask.total = j.scanned || localTask.processed;
              localTask.progress = 1;
              localTask.scan_id = j.scan_id;
            } else {
              provScanMsg.textContent = `Scan error: ${j.error||r.status}`;
              localTask.status = 'error';
              localTask.error = j.error || String(r.status);
              localTask.progress = 1;
            }
          }
        } catch(err){
          provScanMsg.textContent = 'Scan error: ' + err;
          if (localTask){
            localTask.status = 'error';
            localTask.error = (err && err.message) ? err.message : String(err);
            localTask.progress = 1;
          }
        }
        finally {
          if (btn) { btn.disabled = false; btn.textContent = 'Scan'; }
          fetchTasks(); // refresh tasks view to reflect status
        }
      });
    }

    // Scans dropdown and background tasks
    // Recent scans dropdown helpers
    const select = document.getElementById('recent-scans');
    const btnOpen = document.getElementById('open-scan');
    const refreshBtn = document.getElementById('refresh-scans');
    function openSelected(){ const id = select && select.value; if (id) { window.location = '/datasets?scan_id=' + encodeURIComponent(id); } }
    if (select && btnOpen) {
      btnOpen.addEventListener('click', openSelected);
      select.addEventListener('change', openSelected);
    }
    async function loadScansIntoDropdown(){
      try {
        const r = await fetch('/api/scans');
        const scans = await r.json();
        if (!select) return;
        const current = select.value;
        select.innerHTML = '<option value="">-- select --</option>' + scans.map(s => `<option value="${s.id}">${s.path} — ${s.file_count} files — ${Math.round(s.ended||s.started||0)}</option>`).join('');
        if (current) select.value = current;
      } catch(e) { /* ignore */ }
    }
    if (refreshBtn) refreshBtn.addEventListener('click', loadScansIntoDropdown);

    const scanForm = document.getElementById('bg-scan-form');
    const tasksDiv = document.getElementById('tasks-list');
    // Keep a small client-side list for local (synchronous) scans so they appear alongside server tasks
    window.scidkLocalTasks = window.scidkLocalTasks || [];
    const fmtPct = (x) => Math.round((x || 0) * 100);
    function renderTasks(tasks){
      if (!tasks || tasks.length === 0){ tasksDiv.innerHTML = '<p class="small">No background tasks.</p>'; return; }
      tasksDiv.innerHTML = tasks.map(t => {
        const total = (t.total===null||t.total===undefined) ? '?' : (t.total||0);
        const pct = fmtPct(t.progress);
        const color = (t.status==='completed') ? '#4caf50' : (t.status==='error' ? '#e53935' : (t.status==='canceled' ? '#9e9e9e' : (t.status==='canceling' ? '#ff9800' : '#2196f3')));
        const bar = `<div style=\"width:100%; background:#eee; height:10px; border-radius:4px; overflow:hidden\"><div style=\"width:${pct}%; height:10px; background:${color}\"></div></div>`;
        let extra = '';
        if (t.type === 'commit'){
          const attempted = t.neo4j_attempted ? 'yes' : 'no';
          const written = (t.neo4j_written===undefined||t.neo4j_written===null) ? '' : String(t.neo4j_written);
          const dbv = (t.neo4j_db_verified===undefined) ? '' : (t.neo4j_db_verified ? 'ok' : 'fail');
          const dbf = (t.neo4j_db_files||0);
          const dbfo = (t.neo4j_db_folders||0);
          const err = t.neo4j_error ? (` — error: ${t.neo4j_error}`) : '';
          extra = `<div class=\"small\">Neo4j: attempted=${attempted}${written!==''?(' — prepared='+written):''}${dbv!==''?(' — verify='+dbv+' (files:'+dbf+', folders:'+dbfo+')'):''}${err}</div>`;
        }
        const cancelBtn = (t.status==='running' && t.id && !t.local) ? (` <button class=\"btn btn-sm btn-outline-danger task-cancel\" data-task=\"${t.id}\">Cancel</button>`) : '';
        const displayStatus = (t.status==='canceled' || t.status==='canceling') ? 'cancelled' : t.status;
        const info = `<div class=\"small\">${t.type} ${displayStatus} — ${t.path || ''} — ${t.processed||0}/${total} (${pct}%) ${t.error?(' — error: '+t.error):''} ${t.scan_id?(' — <a href=\"/datasets?scan_id='+t.scan_id+'\">open</a>'):''} ${cancelBtn}</div>`;
        return `<div style=\"margin:.25rem 0\">${bar}${info}${extra}</div>`;
      }).join('');
      // attach cancel handlers
      tasksDiv.querySelectorAll('.task-cancel')?.forEach(btn => {
        btn.addEventListener('click', async () => {
          const tid = btn.getAttribute('data-task');
          if (!tid) return;
          // optimistic UI: disable and show canceling
          btn.disabled = true; btn.textContent = 'Canceling…';
          try {
            const r = await fetch('/api/tasks/' + encodeURIComponent(tid) + '/cancel', { method: 'POST' });
            if (!r.ok){ try { const j = await r.json(); alert('Cancel failed: ' + (j.error || r.status)); } catch(_) { alert('Cancel failed: ' + r.status); } }
          } catch(err){ alert('Cancel failed: ' + err); }
          fetchTasks();
        });
      });
    }
    async function fetchTasks(){
      try { const r = await fetch('/api/tasks'); const data = await r.json(); const all = ([]).concat(Array.isArray(data)?data:[]).concat(window.scidkLocalTasks||[]); renderTasks(all); }
      catch(e){ /* ignore */ }
    }
    let poller = null;
    async function fetchNeoStatus(){
      try {
        const r = await fetch('/api/settings/neo4j');
        const j = await r.json();
        const light = document.getElementById('neo4j-light-files');
        const txt = document.getElementById('neo4j-status-text-files');
        const ok = !!(j && j.connected);
        if (light) { light.style.background = ok ? '#19c37d' : '#000'; light.title = ok ? 'Connected' : 'Disconnected'; }
        if (txt) { txt.textContent = ok ? 'Neo4j: Connected' : (j && j.last_error ? ('Neo4j: Error — ' + j.last_error) : 'Neo4j: Not connected'); }
      } catch(e) {
        const txt = document.getElementById('neo4j-status-text-files');
        if (txt) txt.textContent = 'Neo4j: status unavailable';
      }
    }
    function renderScansSummaryRows(scans){
      const tbody = document.getElementById('scans-summary');
      if (!tbody) return;
      const fmtTs = (t) => { try { return t ? new Date(Math.round(t)*1000).toLocaleString() : ''; } catch(_) { return t || ''; } };
      if (!scans || scans.length === 0){ tbody.innerHTML = '<tr><td colspan="7" class="small">No scans yet.</td></tr>'; return; }
      tbody.innerHTML = scans.map(s => `<tr>
        <td><code>${s.id}</code></td>
        <td>${s.path}</td>
        <td>${s.file_count||0}</td>
        <td>${s.recursive?'yes':'no'}</td>
        <td>${fmtTs(s.started)}</td>
        <td>${fmtTs(s.ended)}</td>
        <td>${s.committed?'yes':'no'}</td>
      </tr>`).join('');
    }
    async function startPolling(){
      if (poller) return;
      poller = setInterval(async () => {
        try {
          const r = await fetch('/api/scans');
          const scans = await r.json();
          renderScansSummaryRows(scans);
        } catch(e){ /* ignore */ }
        fetchTasks();
        loadScansIntoDropdown();
        renderScansPanel();
        fetchNeoStatus();
      }, 1000);
    }
    function stopPolling(){ if (poller){ clearInterval(poller); poller = null; } }
    if (scanForm){
      scanForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const path = document.getElementById('scan-path').value.trim();
        const recursive = document.getElementById('scan-recursive').checked;
        try {
          const r = await fetch('/api/tasks', { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ type: 'scan', path, recursive }) });
          if (r.status === 202){ startPolling(); fetchTasks(); }
          else { const j = await r.json(); alert('Task error: ' + (j.error || r.status)); }
        } catch(err){ alert('Task error: ' + err); }
      });
      // initial render
      startPolling(); fetchTasks(); loadScansIntoDropdown(); fetchNeoStatus();
    }

    // Scans management panel
    const scansDiv = document.getElementById('scans-panel');
    function scansRow(s){
      const ts = Math.round(s.ended||s.started||0);
      return `<div style="padding:.25rem 0; border-bottom:1px solid #eee; display:flex; gap:.5rem; align-items:center; justify-content:space-between">
        <div class="small"><code>${s.id}</code> — ${s.path} — files: ${s.file_count} — ${s.recursive?'recursive':'shallow'} — ${ts}</div>
        <div style="display:flex; gap:.5rem">
          <a class="btn btn-sm btn-outline-primary" href="/datasets?scan_id=${s.id}">Open</a>
          <button class="btn btn-sm btn-outline-success" data-scan="${s.id}" data-action="commit">Commit to Graph</button>
          <button class="btn btn-sm btn-outline-danger" data-scan="${s.id}" data-action="delete">Delete</button>
        </div>
      </div>`;
    }
    async function renderScansPanel(){
      try { const r = await fetch('/api/scans'); const scans = await r.json(); scansDiv.innerHTML = scans.map(scansRow).join('') || '<p class="small">No scans yet.</p>'; }
      catch(e){ scansDiv.innerHTML = '<p class="small">Failed to load scans.</p>'; }
      // attach handlers
      scansDiv.querySelectorAll('button[data-action]')?.forEach(btn => {
        btn.addEventListener('click', async () => {
          const id = btn.getAttribute('data-scan');
          const action = btn.getAttribute('data-action');
          try {
            if (action === 'commit'){
              // Start background commit task to show progress in the Tasks panel
              const r = await fetch('/api/tasks', { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ type: 'commit', scan_id: id }) });
              if (r.status === 202){
                alert('Commit started in background. Watch progress above.');
                startPolling(); fetchTasks();
              } else {
                const j = await r.json();
                alert('Commit task error: ' + (j.error || r.status));
              }
            } else if (action === 'delete'){
              const r = await fetch('/api/scans/' + encodeURIComponent(id), { method: 'DELETE' });
              if (!r.ok){ const j = await r.json(); alert('Delete failed: ' + (j.error || r.status)); }
            }
          } catch(err){ alert('Action failed: ' + err); }
          renderScansPanel();
          loadScansIntoDropdown();
        });
      });
    }
    renderScansPanel();

    // File Browser logic
    // Initialize provider UI
    if (provSelect){ loadProviders(); }
  });
</script>
{% endblock %}