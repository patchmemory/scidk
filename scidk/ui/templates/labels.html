{% extends 'base.html' %}
{% block title %}-SciDK-> Labels{% endblock %}
{% block head %}
<style>
  /* Override base.html main width constraint for labels page */
  main {
    max-width: 100% !important;
    padding: 1rem 0.5rem !important;
  }
</style>
{% endblock %}
{% block content %}
<style>
  .labels-container {
    display: flex;
    gap: 0;
    margin-top: 1rem;
    height: calc(100vh - 200px);
    position: relative;
  }

  /* Left Panel: Labels List */
  .labels-list {
    width: 25%;
    min-width: 200px;
    max-width: 50%;
    border: 1px solid #eee;
    border-radius: 4px;
    padding: 0.5rem;
    overflow-y: auto;
    transition: width 0.3s ease, min-width 0.3s ease;
  }
  .labels-list.collapsed {
    width: 40px;
    min-width: 40px;
    padding: 0.25rem;
  }

  /* Center Panel: Editor + Instance Browser */
  .labels-editor {
    flex: 1;
    border: 1px solid #eee;
    border-radius: 4px;
    padding: 1rem;
    overflow-y: auto;
    min-width: 300px;
    display: flex;
    flex-direction: column;
  }

  /* Right Panel: Statistics */
  .labels-statistics {
    width: 25%;
    min-width: 200px;
    max-width: 40%;
    border: 1px solid #eee;
    border-radius: 4px;
    padding: 1rem;
    overflow-y: auto;
    transition: width 0.3s ease, min-width 0.3s ease;
  }
  .labels-statistics.collapsed {
    width: 40px;
    min-width: 40px;
    padding: 0.25rem;
  }

  /* Resizers */
  .resizer {
    width: 8px;
    cursor: col-resize;
    background: transparent;
    position: relative;
    flex-shrink: 0;
  }
  .resizer:hover {
    background: #e0e0e0;
  }
  .resizer::before {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 3px;
    width: 2px;
    background: #ddd;
  }
  .resizer.resizing {
    background: #2196f3;
  }

  /* Collapse/Expand Buttons */
  .collapse-btn {
    position: absolute;
    top: 0.5rem;
    background: #f0f0f0;
    border: 1px solid #ddd;
    border-radius: 4px;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 12px;
    z-index: 10;
    transition: background 0.2s;
  }
  .collapse-btn:hover {
    background: #e0e0e0;
  }
  .collapse-btn-left {
    right: 0.5rem;
  }
  .collapse-btn-right {
    left: 0.5rem;
  }

  /* Read-only mode styles */
  .editor-mode-toggle {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
    align-items: center;
  }
  .readonly-property {
    padding: 0.5rem;
    margin-bottom: 0.5rem;
    background: #f9f9f9;
    border-radius: 4px;
    border-left: 3px solid #2196f3;
  }
  .readonly-relationship {
    padding: 0.5rem;
    margin-bottom: 0.5rem;
    background: #f0f8ff;
    border-radius: 4px;
    border-left: 3px solid #4caf50;
  }
  .badge-type {
    display: inline-block;
    padding: 0.15rem 0.4rem;
    font-size: 0.7rem;
    border-radius: 3px;
    background: #e0e0e0;
    color: #333;
    margin-left: 0.5rem;
  }
  .badge-required {
    background: #ffebee;
    color: #c62828;
  }

  /* Instance Browser */
  .instance-browser {
    margin-top: 2rem;
    border-top: 2px solid #e0e0e0;
    padding-top: 1rem;
  }
  .instance-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.875rem;
  }
  .instance-table th {
    background: #f5f5f5;
    padding: 0.5rem;
    text-align: left;
    border-bottom: 2px solid #ddd;
    font-weight: 600;
  }
  .instance-table td {
    padding: 0.5rem;
    border-bottom: 1px solid #eee;
  }
  .instance-table tr:hover {
    background: #f9f9f9;
  }
  .instance-cell-editable {
    cursor: text;
    min-height: 1.5rem;
    padding: 0.25rem 0.5rem;
    border-radius: 3px;
  }
  .instance-cell-editable:hover {
    background: #fff8e1;
    outline: 1px dashed #ffc107;
  }
  .instance-cell-editing {
    background: #fff;
    outline: 2px solid #2196f3;
  }
  .instance-pagination {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 1rem;
    font-size: 0.875rem;
  }

  .label-item {
    padding: 0.5rem;
    margin-bottom: 0.25rem;
    cursor: pointer;
    border-radius: 4px;
    border: 1px solid transparent;
    user-select: none; /* Prevent text selection during multi-select */
    outline: none; /* Remove default focus outline, we'll use custom styling */
  }
  .label-item:hover {
    background: #f3f3f3;
  }
  .label-item.active {
    background: #e3f2fd;
    border-color: #2196f3;
  }
  .label-item.selected {
    background: #fff3cd;
    border-color: #ffc107;
  }
  .label-item.selected.active {
    background: #ffe69c;
    border-color: #ff9800;
  }
  .label-item.focused {
    box-shadow: 0 0 0 2px #2196f3;
  }
  .property-row, .relationship-row {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
    align-items: center;
  }
  .property-row input, .relationship-row input, .relationship-row select {
    flex: 1;
  }
  .section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
  }
  .empty-state {
    text-align: center;
    color: #999;
    padding: 2rem;
  }
  /* Source label links in incoming relationships */
  .source-label-link:hover {
    text-decoration: underline !important;
    cursor: pointer;
  }
  /* Custom Modal */
  .custom-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1000;
  }
  .custom-modal-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
  }
  .custom-modal-content {
    position: relative;
    background: white;
    max-width: 700px;
    margin: 50px auto;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    z-index: 1001;
  }
  .custom-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem 1.5rem;
    border-bottom: 1px solid #eee;
  }
  .custom-modal-header h5 {
    margin: 0;
    font-size: 1.1rem;
  }
  .custom-modal-close {
    background: none;
    border: none;
    font-size: 1.5rem;
    cursor: pointer;
    padding: 0;
    width: 30px;
    height: 30px;
    line-height: 1;
    color: #666;
  }
  .custom-modal-close:hover {
    color: #000;
  }
  .custom-modal-body {
    padding: 1.5rem;
  }
  .custom-modal-footer {
    padding: 1rem 1.5rem;
    border-top: 1px solid #eee;
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
  }
</style>

<h1>Labels</h1>
<p class="small">Define and manage graph schema labels with properties and relationships.</p>

<div class="labels-container">
  <!-- Left Panel: Label List -->
  <div class="labels-list" id="labels-list">
    <button class="collapse-btn collapse-btn-left" id="collapse-left-btn" title="Collapse panel">◀</button>
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
      <h3 class="small" style="margin: 0;">Labels</h3>
    </div>
    <div style="display: flex; gap: 0.25rem; margin-bottom: 0.5rem; flex-wrap: wrap;">
      <button id="btn-pull-all-neo4j" class="btn btn-sm btn-outline-info" data-testid="pull-all-neo4j-btn" title="Pull all labels from Neo4j" style="flex: 1; font-size: 0.75rem;">Pull All</button>
      <button id="btn-import-arrows" class="btn btn-sm btn-outline-info" data-testid="import-arrows-btn" style="flex: 1; font-size: 0.75rem;">Import</button>
      <button id="btn-export-arrows" class="btn btn-sm btn-outline-info" data-testid="export-arrows-btn" style="flex: 1; font-size: 0.75rem;">Export</button>
    </div>
    <button id="btn-new-label" class="btn btn-sm" data-testid="new-label-btn" style="width: 100%; font-weight: bold; background: #e0e0e0; color: #555; border: 1px solid #ccc; margin-bottom: 0.5rem;">+ Label</button>
    <!-- Batch action buttons (shown when multiple labels selected) -->
    <div id="batch-actions" style="display: none; margin-bottom: 0.5rem; padding: 0.5rem; background: #f0f8ff; border-radius: 4px; border: 1px solid #b3d9ff;">
      <div class="small" style="margin-bottom: 0.25rem;"><strong id="selection-count">0</strong> selected</div>
      <div style="display: flex; gap: 0.25rem; flex-wrap: wrap;">
        <button id="btn-batch-pull" class="btn btn-sm btn-outline-primary" style="flex: 1; font-size: 0.75rem;">Batch Pull</button>
        <button id="btn-batch-delete" class="btn btn-sm btn-outline-danger" style="flex: 1; font-size: 0.75rem;">Batch Delete</button>
        <button id="btn-clear-selection" class="btn btn-sm btn-outline-secondary" style="flex: 1; font-size: 0.75rem;">Clear</button>
      </div>
    </div>
    <div id="label-list" data-testid="label-list">
      <div class="empty-state small">No labels defined</div>
    </div>
  </div>

  <!-- Resizer (Left to Center) -->
  <div class="resizer" id="resizer-left"></div>

  <!-- Center Panel: Label Editor -->
  <div class="labels-editor" id="label-editor" style="display: none;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
      <h3 id="editor-title" style="margin: 0;">New Label</h3>
      <div class="editor-mode-toggle">
        <button id="btn-toggle-mode" class="btn btn-sm btn-outline-primary" data-testid="toggle-edit-mode" style="display: none;">Edit</button>
        <button id="btn-cancel-edit" class="btn btn-sm btn-outline-secondary" data-testid="cancel-edit" style="display: none;">Cancel</button>
      </div>
    </div>

    <!-- Read-only view -->
    <div id="readonly-view" style="display: none;">
      <div style="margin-bottom: 1rem;">
        <label class="form-label small">Name</label>
        <div id="readonly-name" style="padding: 0.5rem; background: #f5f5f5; border-radius: 4px; font-weight: bold;"></div>
      </div>

      <div class="section-header">
        <h4 class="small" style="margin: 0;">Properties</h4>
      </div>
      <div id="readonly-properties-container">
        <div class="empty-state small">No properties defined</div>
      </div>

      <div class="section-header">
        <h4 class="small" style="margin: 0;">Outgoing Relationships</h4>
      </div>
      <div id="readonly-relationships-container">
        <div class="empty-state small">No relationships defined</div>
      </div>

      <div class="section-header" style="margin-top: 1.5rem;">
        <h4 class="small" style="margin: 0;">Incoming Relationships</h4>
      </div>
      <div id="readonly-incoming-relationships-container">
        <div class="empty-state small">No incoming relationships</div>
      </div>

      <div style="margin-top: 1.5rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
        <button id="btn-delete-readonly" class="btn btn-sm btn-outline-danger" data-testid="delete-label-readonly-btn">Delete</button>
        <button id="btn-pull-neo4j-readonly" class="btn btn-sm btn-outline-secondary" data-testid="pull-neo4j-readonly-btn">Pull from Neo4j</button>
      </div>
    </div>

    <!-- Edit view -->
    <div id="edit-view" style="display: none;">
      <div style="margin-bottom: 1rem;">
        <label class="form-label small" for="label-name">Name</label>
        <input id="label-name" type="text" class="form-control form-control-sm" placeholder="e.g., Project" data-testid="label-name" />
        <div id="name-error" class="small" style="color: #b00020; display: none;"></div>
      </div>

      <div class="section-header">
        <h4 class="small" style="margin: 0;">Properties</h4>
        <button id="btn-add-property" class="btn btn-sm btn-outline-primary" data-testid="add-property-btn">Add Property</button>
      </div>
      <div id="properties-container" data-testid="properties-container">
        <div class="empty-state small">No properties defined</div>
      </div>

      <div class="section-header">
        <h4 class="small" style="margin: 0;">Outgoing Relationships</h4>
        <button id="btn-add-relationship" class="btn btn-sm btn-outline-primary" data-testid="add-relationship-btn">Add Relationship</button>
      </div>
      <div id="relationships-container" data-testid="relationships-container">
        <div class="empty-state small">No relationships defined</div>
      </div>

      <div class="section-header" style="margin-top: 1.5rem;">
        <h4 class="small" style="margin: 0;">Incoming Relationships</h4>
      </div>
      <div id="incoming-relationships-container" data-testid="incoming-relationships-container">
        <div class="empty-state small">No incoming relationships</div>
      </div>

      <div style="margin-top: 1.5rem; display: flex; gap: 0.5rem; flex-wrap: wrap;">
        <button id="btn-save" class="btn btn-sm btn-success" data-testid="save-label-btn">Save</button>
        <button id="btn-delete" class="btn btn-sm btn-outline-danger" data-testid="delete-label-btn" style="display: none;">Delete</button>
        <button id="btn-pull-neo4j" class="btn btn-sm btn-outline-secondary" data-testid="pull-neo4j-btn" style="display: none;">Pull</button>
      </div>
    </div>

    <!-- Instance Browser Section -->
    <div class="instance-browser" id="instance-browser" style="display: none;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
        <h4 class="small" style="margin: 0;">Instances</h4>
        <div style="display: flex; gap: 0.5rem;">
          <button id="btn-pull-instances" class="btn btn-sm btn-outline-primary" data-testid="pull-instances-btn">Pull from Neo4j</button>
          <button id="btn-push-instances" class="btn btn-sm btn-success" data-testid="push-instances-btn" style="display: none;">Push Changes</button>
          <button id="btn-refresh-instances" class="btn btn-sm btn-outline-secondary" data-testid="refresh-instances-btn">Refresh</button>
        </div>
      </div>

      <div id="instance-table-container">
        <div class="empty-state small">Click "Pull from Neo4j" to load instances</div>
      </div>

      <div class="instance-pagination" id="instance-pagination" style="display: none;">
        <div class="small" id="instance-page-info">Page 1 of 1 (0 instances)</div>
        <div style="display: flex; gap: 0.5rem;">
          <button id="btn-instance-prev" class="btn btn-sm btn-outline-secondary" disabled>Previous</button>
          <button id="btn-instance-next" class="btn btn-sm btn-outline-secondary" disabled>Next</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Resizer (Center to Right) -->
  <div class="resizer" id="resizer-right"></div>

  <!-- Right Panel: Statistics -->
  <div class="labels-statistics" id="labels-statistics" style="display: none;">
    <button class="collapse-btn collapse-btn-right" id="collapse-right-btn" title="Collapse panel">▶</button>
    <h3 class="small">Statistics</h3>

    <div id="statistics-content">
      <div class="empty-state small">Select a label to view statistics</div>
    </div>
  </div>
</div>

<!-- Import Modal -->
<div id="import-arrows-modal" class="custom-modal" style="display: none;">
  <div class="custom-modal-overlay"></div>
  <div class="custom-modal-content">
    <div class="custom-modal-header">
      <h5>Import Schema</h5>
      <button type="button" class="custom-modal-close" onclick="closeImportModal()">&times;</button>
    </div>
    <div class="custom-modal-body">
      <!-- Import Type Selection -->
      <div style="margin-bottom: 1rem; padding: 0.75rem; background: #f9f9f9; border-radius: 4px;">
        <div style="margin-bottom: 0.5rem;"><strong class="small">Import Type:</strong></div>
        <div style="display: flex; gap: 1rem;">
          <label style="cursor: pointer; display: flex; align-items: center; gap: 0.25rem;">
            <input type="radio" name="import-type" value="arrows" checked data-testid="import-type-arrows">
            <span class="small">Arrows.app JSON</span>
          </label>
          <label style="cursor: pointer; display: flex; align-items: center; gap: 0.25rem;">
            <input type="radio" name="import-type" value="eda" data-testid="import-type-eda">
            <span class="small">NC3Rs EDA File</span>
          </label>
        </div>
      </div>

      <!-- Arrows Import Section -->
      <div id="arrows-import-section">
        <p class="small">Paste JSON exported from <a href="https://arrows.app" target="_blank" rel="noopener">arrows.app</a></p>
        <textarea id="arrows-json-input" class="form-control font-monospace" rows="12" placeholder='{"nodes": [...], "relationships": [...]}'></textarea>
        <div style="margin-top: 0.5rem;">
          <label for="arrows-file-input" class="btn btn-sm btn-outline-secondary">
            Or choose JSON file...
          </label>
          <input type="file" id="arrows-file-input" accept=".json" style="display:none">
          <span id="arrows-file-name" class="small" style="margin-left: 0.5rem;"></span>
        </div>
        <div id="import-preview" style="display:none; margin-top: 1rem; padding: 0.75rem; background: #f9f9f9; border-radius: 4px;">
          <div class="small"><strong>Preview:</strong> <span id="preview-label-count">0</span> labels, <span id="preview-rel-count">0</span> relationships</div>
        </div>
      </div>

      <!-- EDA Import Section -->
      <div id="eda-import-section" style="display: none;">
        <p class="small">Import experimental design from <a href="https://nc3rs.org.uk/eda" target="_blank" rel="noopener">NC3Rs EDA</a> (.eda file)</p>
        <div style="margin-top: 0.5rem;">
          <label for="eda-file-input" class="btn btn-sm btn-outline-success">
            Choose .eda file...
          </label>
          <input type="file" id="eda-file-input" accept=".eda" style="display:none" data-testid="eda-file-input">
          <span id="eda-file-name" class="small" style="margin-left: 0.5rem;"></span>
        </div>
        <div class="small" style="margin-top: 1rem; padding: 0.75rem; background: #f0f8ff; border-radius: 4px; border-left: 3px solid #2196f3;">
          <strong>EDA Files:</strong> ZIP archives containing experimental designs with node types like Treatment, Subject, Measurement, etc.
        </div>
      </div>
    </div>
    <div class="custom-modal-footer">
      <button type="button" class="btn btn-sm btn-outline-secondary" onclick="closeImportModal()">Cancel</button>
      <button type="button" id="import-confirm-btn" class="btn btn-sm btn-success" data-testid="import-confirm-btn">Import</button>
    </div>
  </div>
</div>

<script>
let currentLabel = null;
let labels = [];
let selectedLabels = new Set(); // Track selected label names
let lastClickedIndex = -1; // For shift+click range selection
let selectionAnchor = -1; // Anchor point for shift+navigation selection

// Toast function
function showToast(message, type = 'info') {
  if (typeof window.toast === 'function') {
    window.toast(message, type, 3000);
  } else {
    console.log(`[${type}] ${message}`);
  }
}

// Modal functions
function openImportModal() {
  document.getElementById('import-arrows-modal').style.display = 'block';
  // Reset to Arrows import by default
  document.querySelector('input[name="import-type"][value="arrows"]').checked = true;
  switchImportType('arrows');
}

function closeImportModal() {
  const modal = document.getElementById('import-arrows-modal');
  modal.style.display = 'none';
  // Clear all inputs
  document.getElementById('arrows-json-input').value = '';
  document.getElementById('arrows-file-name').textContent = '';
  document.getElementById('eda-file-name').textContent = '';
  document.getElementById('import-preview').style.display = 'none';
  // Reset file inputs
  document.getElementById('arrows-file-input').value = '';
  document.getElementById('eda-file-input').value = '';
}

function switchImportType(type) {
  const arrowsSection = document.getElementById('arrows-import-section');
  const edaSection = document.getElementById('eda-import-section');

  if (type === 'arrows') {
    arrowsSection.style.display = 'block';
    edaSection.style.display = 'none';
  } else if (type === 'eda') {
    arrowsSection.style.display = 'none';
    edaSection.style.display = 'block';
  }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOMContentLoaded - initializing labels page');

  try {
    loadLabels();
    console.log('loadLabels() called successfully');
  } catch (e) {
    console.error('Error calling loadLabels():', e);
  }

  try {
    document.getElementById('btn-new-label').addEventListener('click', () => {
      currentLabel = null;
      showEditor();
      clearEditor();
      document.getElementById('editor-title').textContent = 'New Label';
      document.getElementById('btn-delete').style.display = 'none';
      document.getElementById('btn-pull-neo4j').style.display = 'none';
      // For new labels, start in edit mode
      isEditMode = true;
      updateEditorView();
    });
    console.log('btn-new-label listener attached');
  } catch (e) {
    console.error('Error attaching btn-new-label listener:', e);
  }

  try {
    document.getElementById('btn-save').addEventListener('click', saveLabel);
    document.getElementById('btn-delete').addEventListener('click', deleteLabel);
    document.getElementById('btn-pull-neo4j').addEventListener('click', pullFromNeo4j);
    document.getElementById('btn-pull-all-neo4j').addEventListener('click', pullAllFromNeo4j);
    document.getElementById('btn-add-property').addEventListener('click', addProperty);
    document.getElementById('btn-add-relationship').addEventListener('click', addRelationship);
    console.log('Main editor button listeners attached');
  } catch (e) {
    console.error('Error attaching main editor listeners:', e);
  }

  try {
    // Mode toggle buttons
    document.getElementById('btn-toggle-mode').addEventListener('click', toggleEditMode);
    document.getElementById('btn-cancel-edit').addEventListener('click', cancelEdit);
    document.getElementById('btn-delete-readonly').addEventListener('click', deleteLabel);
    document.getElementById('btn-pull-neo4j-readonly').addEventListener('click', pullFromNeo4j);
    console.log('Mode toggle listeners attached');
  } catch (e) {
    console.error('Error attaching mode toggle listeners:', e);
  }

  try {
    // Instance browser buttons
    document.getElementById('btn-pull-instances').addEventListener('click', pullInstances);
    document.getElementById('btn-push-instances').addEventListener('click', pushInstances);
    document.getElementById('btn-refresh-instances').addEventListener('click', refreshInstances);
    document.getElementById('btn-instance-prev').addEventListener('click', () => navigateInstances(-1));
    document.getElementById('btn-instance-next').addEventListener('click', () => navigateInstances(1));
    console.log('Instance browser listeners attached');
  } catch (e) {
    console.error('Error attaching instance browser listeners:', e);
  }

  // Batch action buttons
  document.getElementById('btn-batch-pull').addEventListener('click', batchPull);
  document.getElementById('btn-batch-delete').addEventListener('click', batchDelete);
  document.getElementById('btn-clear-selection').addEventListener('click', clearSelection);

  // Arrows.app Import/Export
  document.getElementById('btn-import-arrows')?.addEventListener('click', openImportModal);
  document.getElementById('btn-export-arrows')?.addEventListener('click', exportToArrows);

  // Import type radio button handling
  document.querySelectorAll('input[name="import-type"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
      switchImportType(e.target.value);
    });
  });

  // Arrows file input
  document.getElementById('arrows-file-input')?.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (ev) => {
        document.getElementById('arrows-json-input').value = ev.target.result;
        document.getElementById('arrows-file-name').textContent = file.name;
        previewArrowsImport();
      };
      reader.readAsText(file);
    }
  });

  document.getElementById('arrows-json-input')?.addEventListener('input', previewArrowsImport);

  // EDA file input
  document.getElementById('eda-file-input')?.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
      document.getElementById('eda-file-name').textContent = file.name;
    } else {
      document.getElementById('eda-file-name').textContent = '';
    }
  });

  // Unified import confirm button
  document.getElementById('import-confirm-btn')?.addEventListener('click', async () => {
    const selectedType = document.querySelector('input[name="import-type"]:checked').value;

    if (selectedType === 'arrows') {
      importFromArrows();
    } else if (selectedType === 'eda') {
      const fileInput = document.getElementById('eda-file-input');
      const file = fileInput.files[0];

      if (!file) {
        alert('Please select an .eda file');
        return;
      }

      if (!file.name.endsWith('.eda')) {
        alert('File must be .eda format');
        return;
      }

      const formData = new FormData();
      formData.append('file', file);

      try {
        const resp = await fetch('/api/labels/import/eda', {
          method: 'POST',
          body: formData
        });

        const result = await resp.json();
        if (result.status === 'success') {
          const msg = `Successfully imported ${result.imported.labels} labels and ${result.imported.relationships} relationships from ${file.name}`;
          if (result.skipped && result.skipped.length > 0) {
            alert(msg + `\n\nSkipped ${result.skipped.length} existing labels: ${result.skipped.join(', ')}`);
          } else {
            alert(msg);
          }
          loadLabels();  // Refresh label list
          closeImportModal();
        } else {
          alert('Import failed: ' + result.error);
        }
      } catch (err) {
        alert('Import error: ' + err.message);
      }
    }
  });

  // Keyboard navigation
  document.addEventListener('keydown', handleGlobalKeydown);

  // Collapse/Expand functionality
  const collapseLeftBtn = document.getElementById('collapse-left-btn');
  const collapseRightBtn = document.getElementById('collapse-right-btn');
  const leftPanel = document.getElementById('labels-list');
  const rightPanel = document.getElementById('labels-statistics');

  collapseLeftBtn.addEventListener('click', () => {
    leftPanel.classList.toggle('collapsed');
    collapseLeftBtn.textContent = leftPanel.classList.contains('collapsed') ? '▶' : '◀';
    collapseLeftBtn.title = leftPanel.classList.contains('collapsed') ? 'Expand panel' : 'Collapse panel';
  });

  collapseRightBtn.addEventListener('click', () => {
    rightPanel.classList.toggle('collapsed');
    collapseRightBtn.textContent = rightPanel.classList.contains('collapsed') ? '◀' : '▶';
    collapseRightBtn.title = rightPanel.classList.contains('collapsed') ? 'Expand panel' : 'Collapse panel';
  });

  // Resizer functionality for both dividers
  const resizerLeft = document.getElementById('resizer-left');
  const resizerRight = document.getElementById('resizer-right');
  const container = document.querySelector('.labels-container');

  let activeResizer = null;

  function startResize(resizer) {
    activeResizer = resizer;
    resizer.classList.add('resizing');
    document.body.style.cursor = 'col-resize';
    document.body.style.userSelect = 'none';
  }

  resizerLeft.addEventListener('mousedown', (e) => {
    e.preventDefault();
    startResize(resizerLeft);
  });

  resizerRight.addEventListener('mousedown', (e) => {
    e.preventDefault();
    startResize(resizerRight);
  });

  document.addEventListener('mousemove', (e) => {
    if (!activeResizer) return;

    const containerRect = container.getBoundingClientRect();

    if (activeResizer === resizerLeft) {
      // Resize left panel
      const newWidth = e.clientX - containerRect.left;
      const minWidth = leftPanel.classList.contains('collapsed') ? 40 : 200;
      const maxWidth = containerRect.width * 0.5;

      if (newWidth >= minWidth && newWidth <= maxWidth) {
        leftPanel.style.width = `${newWidth}px`;
      }
    } else if (activeResizer === resizerRight) {
      // Resize right panel
      const newWidth = containerRect.right - e.clientX;
      const minWidth = rightPanel.classList.contains('collapsed') ? 40 : 200;
      const maxWidth = containerRect.width * 0.4;

      if (newWidth >= minWidth && newWidth <= maxWidth) {
        rightPanel.style.width = `${newWidth}px`;
      }
    }
  });

  document.addEventListener('mouseup', () => {
    if (activeResizer) {
      activeResizer.classList.remove('resizing');
      activeResizer = null;
      document.body.style.cursor = '';
      document.body.style.userSelect = '';
    }
  });
});

// Global keyboard navigation handler
function handleGlobalKeydown(e) {
  // Don't intercept if user is typing in an input/textarea/select
  const activeElement = document.activeElement;
  const isTyping = activeElement && (
    activeElement.tagName === 'INPUT' ||
    activeElement.tagName === 'TEXTAREA' ||
    activeElement.tagName === 'SELECT'
  );

  // Let buttons and links handle Enter/Space themselves, UNLESS we're actively navigating labels
  if (activeElement && (activeElement.tagName === 'BUTTON' || activeElement.tagName === 'A') && (e.key === 'Enter' || e.key === ' ')) {
    // If we're navigating in the label list (lastClickedIndex is set), prioritize that
    if (e.key === 'Enter' && lastClickedIndex >= 0 && lastClickedIndex < labels.length) {
      // Check if we're still in the label navigation context (not tabbed away)
      const focusIsInSidePanel = activeElement.closest('#labels-list');
      if (focusIsInSidePanel) {
        e.preventDefault();
        loadLabel(labels[lastClickedIndex].name);
        return;
      }
    }
    // Button/link is focused and we're not in side panel navigation - let it work normally
    return;
  }

  // Handle up/down navigation within editor fields (properties and relationships)
  if (isTyping && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
    const isInEditor = activeElement.closest('#label-editor');
    if (isInEditor) {
      // For SELECT elements, only allow up/down if dropdown is already open
      if (activeElement.tagName === 'SELECT') {
        // Check if select is expanded (we'll prevent default unless Enter was pressed)
        if (!activeElement.dataset.dropdownOpen) {
          e.preventDefault();
          navigateEditorFields(e.key === 'ArrowUp' ? -1 : 1);
          return;
        }
        // If dropdown is open, allow normal behavior
        return;
      }

      // For INPUT fields, allow up/down to navigate between rows
      if (activeElement.tagName === 'INPUT') {
        e.preventDefault();
        navigateEditorFields(e.key === 'ArrowUp' ? -1 : 1);
        return;
      }
    }
  }

  // Handle up/down navigation for buttons within editor rows (delete, nav buttons)
  if (!isTyping && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
    const isInEditorRow = activeElement && activeElement.closest('.property-row, .relationship-row');
    if (isInEditorRow && activeElement.tagName === 'BUTTON') {
      e.preventDefault();
      navigateEditorFields(e.key === 'ArrowUp' ? -1 : 1);
      return;
    }
  }

  // For SELECT elements in editor: Enter/Space opens dropdown, letter keys search, Escape closes it
  if (activeElement && activeElement.tagName === 'SELECT' && activeElement.closest('#label-editor')) {
    if (e.key === 'Enter' || e.key === ' ') {
      activeElement.dataset.dropdownOpen = 'true';
      return; // Allow default behavior
    } else if (e.key === 'Escape') {
      // If dropdown is open, close it; otherwise return focus to side panel
      if (activeElement.dataset.dropdownOpen) {
        activeElement.dataset.dropdownOpen = '';
        activeElement.blur();
        return;
      }
      // If dropdown not open, fall through to general Escape handling
    } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
      // Letter/number key: open dropdown and allow search
      activeElement.dataset.dropdownOpen = 'true';
      return; // Allow default behavior for letter search
    }
  }

  // Escape key in editor: return focus to side panel
  if (e.key === 'Escape' && !isTyping) {
    const isInEditor = activeElement && activeElement.closest('#label-editor');
    if (isInEditor && lastClickedIndex >= 0 && lastClickedIndex < labels.length) {
      e.preventDefault();
      returnFocusToSidePanel();
      return;
    }
  }

  // Escape key while typing in editor: return focus to side panel
  if (e.key === 'Escape' && isTyping) {
    const isInEditor = activeElement && activeElement.closest('#label-editor');
    if (isInEditor) {
      e.preventDefault();
      returnFocusToSidePanel();
      return;
    }
  }

  // Handle Ctrl+A (select all labels) - works even when not typing
  if ((e.ctrlKey || e.metaKey) && e.key === 'a' && !isTyping) {
    e.preventDefault();
    selectAllLabels();
    return;
  }

  // Escape key in side panel: move focus to top buttons
  if (e.key === 'Escape' && !isTyping) {
    const isInSidePanel = activeElement && activeElement.closest('#labels-list');
    if (isInSidePanel) {
      e.preventDefault();
      returnFocusToTopButtons();
      return;
    }
  }

  // Tab key in side panel: check if we're navigating out to top buttons
  if (e.key === 'Tab' && !isTyping && !e.shiftKey) {
    const isInLabelList = activeElement && activeElement.classList.contains('label-item');
    if (isInLabelList) {
      // Clear label selection state when tabbing out
      clearLabelNavigationState();
    }
  }

  // Shift+Tab into side panel from editor: set up navigation state
  if (e.key === 'Tab' && !isTyping && e.shiftKey) {
    const isInEditor = activeElement && activeElement.closest('#label-editor');
    if (isInEditor && currentLabel) {
      // User is shift-tabbing from editor, might go back to side panel
      // We'll handle this after the focus change
    }
  }

  // Don't handle other keys if user is typing
  if (isTyping) return;

  // Check if shift is held for range selection
  const shiftHeld = e.shiftKey;

  // Handle navigation keys
  switch(e.key) {
    case 'ArrowUp':
      e.preventDefault();
      navigateLabels(-1, shiftHeld);
      break;
    case 'ArrowDown':
      e.preventDefault();
      navigateLabels(1, shiftHeld);
      break;
    case 'Home':
      e.preventDefault();
      navigateToLabel(0, shiftHeld);
      break;
    case 'End':
      e.preventDefault();
      navigateToLabel(labels.length - 1, shiftHeld);
      break;
    case 'PageUp':
      e.preventDefault();
      navigateLabels(-10, shiftHeld);
      break;
    case 'PageDown':
      e.preventDefault();
      navigateLabels(10, shiftHeld);
      break;
    case 'Enter':
      // Only handle Enter for label loading if we're not focused on an interactive element
      if (lastClickedIndex >= 0 && lastClickedIndex < labels.length) {
        // Don't interfere if focus is in the editor
        const focusInEditor = document.activeElement && document.activeElement.closest('#label-editor');
        if (!focusInEditor) {
          e.preventDefault();
          loadLabel(labels[lastClickedIndex].name);
        }
      }
      break;
    case 'Delete':
      if (selectedLabels.size > 0) {
        e.preventDefault();
        batchDelete();
      }
      break;
    case 'p':
    case 'P':
      if (selectedLabels.size > 0) {
        e.preventDefault();
        batchPull();
      }
      break;
    case 'd':
    case 'D':
      if (selectedLabels.size > 0) {
        e.preventDefault();
        batchDelete();
      }
      break;
    case 'c':
    case 'C':
      if (selectedLabels.size > 0) {
        e.preventDefault();
        clearSelection();
      }
      break;
  }
}

function navigateLabels(delta, shiftHeld = false) {
  if (labels.length === 0) return;

  let newIndex;
  if (lastClickedIndex === -1) {
    // No label selected yet, start at beginning
    newIndex = delta > 0 ? 0 : labels.length - 1;
  } else {
    newIndex = lastClickedIndex + delta;
  }

  // Clamp to valid range
  newIndex = Math.max(0, Math.min(labels.length - 1, newIndex));

  navigateToLabel(newIndex, shiftHeld);
}

function navigateToLabel(index, shiftHeld = false) {
  if (index < 0 || index >= labels.length) return;

  if (shiftHeld) {
    // Set anchor if this is the first shift+navigation
    if (selectionAnchor === -1) {
      selectionAnchor = lastClickedIndex !== -1 ? lastClickedIndex : index;
    }

    // Clear current selection and reselect from anchor to new position
    selectedLabels.clear();
    const start = Math.min(selectionAnchor, index);
    const end = Math.max(selectionAnchor, index);
    for (let i = start; i <= end; i++) {
      if (i < labels.length) {
        selectedLabels.add(labels[i].name);
      }
    }
  } else {
    // Normal navigation: clear selection and reset anchor
    clearSelection();
    selectionAnchor = -1;
  }

  lastClickedIndex = index;

  // Visual highlight by making it "active"
  renderLabelList();

  // Scroll into view
  const container = document.getElementById('label-list');
  const items = container.querySelectorAll('.label-item');
  if (items[index]) {
    items[index].scrollIntoView({ block: 'nearest', behavior: 'smooth' });
  }
}

function selectAllLabels() {
  selectedLabels.clear();
  labels.forEach(label => selectedLabels.add(label.name));
  renderLabelList();
}

// Navigate between editor fields (properties and relationships) with up/down arrows
// Navigates within the same column (e.g., property names, types, checkboxes)
function navigateEditorFields(direction) {
  const activeElement = document.activeElement;
  if (!activeElement) return;

  const currentRow = activeElement.closest('.property-row, .relationship-row');
  if (!currentRow) return;

  // Determine which column we're in based on the active element
  let fieldType = activeElement.dataset.field;

  if (!fieldType) {
    if (activeElement.type === 'checkbox') {
      fieldType = 'checkbox';
    } else if (activeElement.classList.contains('btn-outline-danger') ||
               activeElement.textContent === '×') {
      fieldType = 'delete-btn';
    } else if (activeElement.classList.contains('target-label-nav')) {
      fieldType = 'nav-btn';
    } else {
      // Unrecognized field type, don't navigate
      return;
    }
  }

  // Get the container (properties or relationships)
  const container = currentRow.parentElement;
  const rows = Array.from(container.querySelectorAll('.property-row, .relationship-row'));
  const currentRowIndex = rows.indexOf(currentRow);

  // Calculate target row
  let targetRowIndex = currentRowIndex + direction;

  // Wrap around
  if (targetRowIndex < 0) targetRowIndex = rows.length - 1;
  if (targetRowIndex >= rows.length) targetRowIndex = 0;

  const targetRow = rows[targetRowIndex];
  if (!targetRow) return;

  // Find the same field type in the target row
  let targetField;
  if (fieldType === 'checkbox') {
    targetField = targetRow.querySelector('input[type="checkbox"]');
  } else if (fieldType === 'delete-btn') {
    targetField = targetRow.querySelector('.btn-outline-danger');
  } else if (fieldType === 'nav-btn') {
    targetField = targetRow.querySelector('.target-label-nav');
  } else {
    targetField = targetRow.querySelector(`[data-field="${fieldType}"]`);
  }

  if (targetField) {
    targetField.focus();

    // For text inputs, select all text
    if (targetField.tagName === 'INPUT' && targetField.type === 'text') {
      targetField.select();
    }
  }
}

// Attach event handlers to SELECT elements to track dropdown state
function attachSelectHandlers(container) {
  container.querySelectorAll('select').forEach(select => {
    // Clear dropdown state on change or blur
    select.addEventListener('change', () => {
      select.dataset.dropdownOpen = '';
    });
    select.addEventListener('blur', () => {
      select.dataset.dropdownOpen = '';
    });
  });
}

// Return focus to the side panel (currently selected label)
function returnFocusToSidePanel() {
  const container = document.getElementById('label-list');
  const items = container.querySelectorAll('.label-item');
  if (lastClickedIndex >= 0 && lastClickedIndex < items.length) {
    items[lastClickedIndex].focus();
  }
}

// Return focus to top buttons (Pull All, Import, Export, + Label)
function returnFocusToTopButtons() {
  const firstButton = document.getElementById('btn-pull-all-neo4j');
  if (firstButton) {
    firstButton.focus();
  }
}

// Clear label navigation state when tabbing out of side panel
function clearLabelNavigationState() {
  lastClickedIndex = -1;
  selectionAnchor = -1;
}

function loadLabels() {
  console.log('loadLabels() executing, fetching /api/labels');
  const container = document.getElementById('label-list');
  container.innerHTML = '<div class="empty-state small" style="padding: 2rem; text-align: center;">Loading labels...</div>';

  fetch('/api/labels')
    .then(r => {
      console.log('loadLabels() got response, status:', r.status);
      if (!r.ok) {
        throw new Error(`HTTP ${r.status}: ${r.statusText}`);
      }
      return r.json();
    })
    .then(data => {
      console.log('loadLabels() got data, count:', (data.labels || []).length);
      if (data.status === 'success') {
        labels = data.labels || [];
        renderLabelList();
        if (labels.length === 0) {
          console.log('No labels found. Try clicking "Pull All" to import from Neo4j.');
        }
      } else {
        console.error('API returned error:', data.error);
        showToast('Error loading labels: ' + (data.error || 'Unknown error'), 'error');
        container.innerHTML = '<div class="empty-state small">Error loading labels. Check console.</div>';
      }
    })
    .catch(err => {
      console.error('loadLabels() error:', err);
      showToast('Network error: ' + err.message, 'error');
      container.innerHTML = '<div class="empty-state small">Network error. Check console.</div>';
    });
}

function renderLabelList() {
  const container = document.getElementById('label-list');
  if (labels.length === 0) {
    container.innerHTML = '<div class="empty-state small">No labels defined</div>';
    updateBatchActionsVisibility();
    return;
  }

  // Compute incoming relationship counts for each label
  const incomingCounts = {};
  labels.forEach(label => {
    incomingCounts[label.name] = 0;
  });
  labels.forEach(label => {
    (label.relationships || []).forEach(rel => {
      if (rel.target_label && incomingCounts[rel.target_label] !== undefined) {
        incomingCounts[rel.target_label]++;
      }
    });
  });

  container.innerHTML = labels.map((label, index) => {
    const outgoing = label.relationships.length;
    const incoming = incomingCounts[label.name] || 0;
    const total = outgoing + incoming;
    const relText = total === 1 ? '1 relationship' : `${total} relationships`;
    const detailText = incoming > 0 ? ` (${outgoing} out, ${incoming} in)` : '';

    const isActive = currentLabel && currentLabel.name === label.name;
    const isSelected = selectedLabels.has(label.name);
    const isFocused = lastClickedIndex === index;
    const classes = ['label-item', isActive && 'active', isSelected && 'selected', isFocused && 'focused'].filter(Boolean).join(' ');

    return `
      <div class="${classes}"
           data-label="${label.name}"
           data-index="${index}"
           data-testid="label-item"
           tabindex="${isFocused ? '0' : '-1'}">
        <strong>${label.name}</strong>
        <div class="small">${label.properties.length} properties, ${relText}${detailText}</div>
      </div>
    `;
  }).join('');

  // Add click handlers with multi-select support
  container.querySelectorAll('.label-item').forEach(item => {
    item.addEventListener('click', (e) => {
      const labelName = item.dataset.label;
      const index = parseInt(item.dataset.index);

      if (e.ctrlKey || e.metaKey) {
        // Ctrl/Cmd+Click: Toggle selection
        toggleLabelSelection(labelName);
        lastClickedIndex = index;
        selectionAnchor = -1; // Reset anchor on ctrl-click
      } else if (e.shiftKey && lastClickedIndex !== -1) {
        // Shift+Click: Range selection
        selectLabelRange(lastClickedIndex, index);
      } else {
        // Regular click: Clear selection and load label
        clearSelection();
        loadLabel(labelName);
        lastClickedIndex = index;
        selectionAnchor = -1; // Reset anchor on regular click
      }
    });
  });

  updateBatchActionsVisibility();
}

function toggleLabelSelection(labelName) {
  if (selectedLabels.has(labelName)) {
    selectedLabels.delete(labelName);
  } else {
    selectedLabels.add(labelName);
  }
  renderLabelList();
}

function selectLabelRange(startIndex, endIndex) {
  const start = Math.min(startIndex, endIndex);
  const end = Math.max(startIndex, endIndex);

  for (let i = start; i <= end; i++) {
    if (i < labels.length) {
      selectedLabels.add(labels[i].name);
    }
  }

  renderLabelList();
}

function clearSelection() {
  selectedLabels.clear();
  selectionAnchor = -1; // Reset anchor when clearing selection
  renderLabelList();
}

function updateBatchActionsVisibility() {
  const batchActions = document.getElementById('batch-actions');
  const selectionCount = document.getElementById('selection-count');

  if (selectedLabels.size > 0) {
    batchActions.style.display = 'block';
    selectionCount.textContent = selectedLabels.size;
  } else {
    batchActions.style.display = 'none';
  }
}

function loadLabel(name) {
  fetch(`/api/labels/${name}`)
    .then(r => r.json())
    .then(data => {
      if (data.status === 'success') {
        currentLabel = data.label;
        showEditor();
        populateEditor(currentLabel);
        renderLabelList(); // Update active state

        // Keep focus in the side panel after loading
        setTimeout(() => {
          const container = document.getElementById('label-list');
          const items = container.querySelectorAll('.label-item');
          if (lastClickedIndex >= 0 && lastClickedIndex < items.length) {
            items[lastClickedIndex].focus();
          }
        }, 0);
      } else {
        showToast('Error loading label: ' + (data.error || 'Unknown error'), 'error');
      }
    })
    .catch(err => showToast('Network error: ' + err.message, 'error'));
}

function showEditor() {
  document.getElementById('label-editor').style.display = 'flex';
  document.getElementById('labels-statistics').style.display = 'block';
}

let isEditMode = false;

function clearEditor() {
  document.getElementById('label-name').value = '';
  document.getElementById('label-name').readOnly = false;
  document.getElementById('properties-container').innerHTML = '<div class="empty-state small">No properties defined</div>';
  document.getElementById('relationships-container').innerHTML = '<div class="empty-state small">No relationships defined</div>';
  document.getElementById('incoming-relationships-container').innerHTML = '<div class="empty-state small">No incoming relationships</div>';
  document.getElementById('name-error').style.display = 'none';

  // Also clear read-only view
  document.getElementById('readonly-name').textContent = '';
  document.getElementById('readonly-properties-container').innerHTML = '<div class="empty-state small">No properties defined</div>';
  document.getElementById('readonly-relationships-container').innerHTML = '<div class="empty-state small">No relationships defined</div>';
  document.getElementById('readonly-incoming-relationships-container').innerHTML = '<div class="empty-state small">No incoming relationships</div>';
}

function toggleEditMode() {
  isEditMode = !isEditMode;
  updateEditorView();
}

function cancelEdit() {
  isEditMode = false;
  // Reload current label to discard changes
  if (currentLabel) {
    populateEditor(currentLabel);
  }
  updateEditorView();
}

function updateEditorView() {
  const readonlyView = document.getElementById('readonly-view');
  const editView = document.getElementById('edit-view');
  const toggleBtn = document.getElementById('btn-toggle-mode');
  const cancelBtn = document.getElementById('btn-cancel-edit');

  if (isEditMode) {
    readonlyView.style.display = 'none';
    editView.style.display = 'block';
    toggleBtn.style.display = 'none';
    cancelBtn.style.display = 'inline-block';
  } else {
    readonlyView.style.display = 'block';
    editView.style.display = 'none';
    // Only show toggle button if we have a current label (not for new labels)
    if (currentLabel) {
      toggleBtn.style.display = 'inline-block';
    } else {
      toggleBtn.style.display = 'none';
    }
    cancelBtn.style.display = 'none';
  }
}

function populateEditor(label) {
  document.getElementById('editor-title').textContent = label.name;

  // Start in read-only mode for existing labels
  isEditMode = false;

  // Show instance browser
  document.getElementById('instance-browser').style.display = 'block';

  // Populate read-only view
  document.getElementById('readonly-name').textContent = label.name;

  const readonlyPropsContainer = document.getElementById('readonly-properties-container');
  if (label.properties.length === 0) {
    readonlyPropsContainer.innerHTML = '<div class="empty-state small">No properties defined</div>';
  } else {
    readonlyPropsContainer.innerHTML = label.properties.map(prop => `
      <div class="readonly-property">
        <strong>${prop.name}</strong>
        <span class="badge-type">${prop.type}</span>
        ${prop.required ? '<span class="badge-type badge-required">required</span>' : ''}
      </div>
    `).join('');
  }

  const readonlyRelsContainer = document.getElementById('readonly-relationships-container');
  if (label.relationships.length === 0) {
    readonlyRelsContainer.innerHTML = '<div class="empty-state small">No relationships defined</div>';
  } else {
    readonlyRelsContainer.innerHTML = label.relationships.map(rel => `
      <div class="readonly-relationship">
        <strong>[${rel.type}]</strong> → ${rel.target_label}
      </div>
    `).join('');
  }

  const readonlyIncomingContainer = document.getElementById('readonly-incoming-relationships-container');
  const incomingRels = label.incoming_relationships || [];
  if (incomingRels.length === 0) {
    readonlyIncomingContainer.innerHTML = '<div class="empty-state small">No incoming relationships</div>';
  } else {
    readonlyIncomingContainer.innerHTML = incomingRels.map(rel => `
      <div class="readonly-relationship">
        <strong>${rel.source_label}</strong> → [${rel.type}]
      </div>
    `).join('');
  }

  // Populate edit view (same as before)
  document.getElementById('label-name').value = label.name;
  document.getElementById('label-name').readOnly = true;
  document.getElementById('btn-delete').style.display = 'inline-block';
  document.getElementById('btn-pull-neo4j').style.display = 'inline-block';

  // Populate statistics panel
  populateStatistics(label);

  // Render properties (edit view)
  const propsContainer = document.getElementById('properties-container');
  if (label.properties.length === 0) {
    propsContainer.innerHTML = '<div class="empty-state small">No properties defined</div>';
  } else {
    propsContainer.innerHTML = label.properties.map((prop, i) => createPropertyRow(prop, i)).join('');
    attachSelectHandlers(propsContainer);
  }

  // Render outgoing relationships
  const relsContainer = document.getElementById('relationships-container');
  if (label.relationships.length === 0) {
    relsContainer.innerHTML = '<div class="empty-state small">No relationships defined</div>';
  } else {
    relsContainer.innerHTML = label.relationships.map((rel, i) => createRelationshipRow(rel, i)).join('');

    // Add click handlers for navigation buttons
    relsContainer.querySelectorAll('.target-label-nav').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        const targetLabel = btn.dataset.target;
        if (targetLabel) {
          loadLabel(targetLabel);
        }
      });
    });

    attachSelectHandlers(relsContainer);
  }

  // Render incoming relationships (edit view - with clickable source labels)
  const incomingContainer = document.getElementById('incoming-relationships-container');
  const incomingRelsEdit = label.incoming_relationships || [];
  if (incomingRelsEdit.length === 0) {
    incomingContainer.innerHTML = '<div class="empty-state small">No incoming relationships</div>';
  } else {
    incomingContainer.innerHTML = incomingRelsEdit.map(rel =>
      `<div class="relationship-row" style="background: #f9f9f9; padding: 0.5rem; margin-bottom: 0.25rem; border-radius: 4px;">
        <span class="small">
          <a href="#" class="source-label-link" data-label="${rel.source_label}" style="color: var(--accent); text-decoration: none; font-weight: bold;">
            ${rel.source_label}
          </a> → [${rel.type}] → <em>this label</em>
        </span>
      </div>`
    ).join('');

    // Add click handlers for source label links
    incomingContainer.querySelectorAll('.source-label-link').forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const sourceLabelName = link.dataset.label;
        loadLabel(sourceLabelName);
      });
    });
  }

  // Set to read-only mode
  updateEditorView();
}

function addProperty() {
  const container = document.getElementById('properties-container');
  if (container.querySelector('.empty-state')) {
    container.innerHTML = '';
  }
  container.insertAdjacentHTML('beforeend', createPropertyRow({name: '', type: 'string', required: false}));
  attachSelectHandlers(container);
}

function createPropertyRow(prop, index) {
  return `
    <div class="property-row" data-index="${index || ''}" data-testid="property-row">
      <input type="text" class="form-control form-control-sm" placeholder="Property name"
             value="${prop.name || ''}" data-field="name" data-testid="property-name" />
      <select class="form-select form-select-sm" data-field="type" data-testid="property-type">
        <option value="string" ${prop.type === 'string' ? 'selected' : ''}>string</option>
        <option value="number" ${prop.type === 'number' ? 'selected' : ''}>number</option>
        <option value="boolean" ${prop.type === 'boolean' ? 'selected' : ''}>boolean</option>
        <option value="date" ${prop.type === 'date' ? 'selected' : ''}>date</option>
        <option value="datetime" ${prop.type === 'datetime' ? 'selected' : ''}>datetime</option>
      </select>
      <div class="form-check" style="flex: 0 0 auto; display: flex; align-items: center;">
        <input type="checkbox" class="form-check-input" ${prop.required ? 'checked' : ''}
               data-field="required" data-testid="property-required" />
        <label class="form-check-label small" style="margin-left: 0.25rem;">Required</label>
      </div>
      <button class="btn btn-sm btn-outline-danger" onclick="this.parentElement.remove()" data-testid="remove-property-btn">×</button>
    </div>
  `;
}

function addRelationship() {
  const container = document.getElementById('relationships-container');
  if (container.querySelector('.empty-state')) {
    container.innerHTML = '';
  }
  container.insertAdjacentHTML('beforeend', createRelationshipRow({type: '', target_label: '', properties: []}));
  attachSelectHandlers(container);
}

function createRelationshipRow(rel, index) {
  const labelOptions = labels.map(l =>
    `<option value="${l.name}" ${rel.target_label === l.name ? 'selected' : ''}>${l.name}</option>`
  ).join('\n        ');

  // Add navigation button if target label is selected
  const hasTarget = rel.target_label && rel.target_label !== '';
  const navButton = hasTarget
    ? `<button class="btn btn-sm btn-outline-primary target-label-nav" data-target="${rel.target_label}" title="Go to ${rel.target_label}" style="flex: 0 0 auto;">→</button>`
    : '';

  return `
    <div class="relationship-row" data-index="${index || ''}" data-testid="relationship-row">
      <input type="text" class="form-control form-control-sm" placeholder="Type (e.g., HAS_FILE)"
             value="${rel.type || ''}" data-field="type" data-testid="relationship-type" />
      <select class="form-select form-select-sm" data-field="target_label" data-testid="relationship-target">
        <option value="">-- Select target label --</option>
        ${labelOptions}
      </select>
      ${navButton}
      <button class="btn btn-sm btn-outline-danger" onclick="this.parentElement.remove()" data-testid="remove-relationship-btn">×</button>
    </div>
  `;
}

function saveLabel() {
  const name = document.getElementById('label-name').value.trim();
  if (!name) {
    document.getElementById('name-error').textContent = 'Label name is required';
    document.getElementById('name-error').style.display = 'block';
    return;
  }
  document.getElementById('name-error').style.display = 'none';

  // Gather properties
  const properties = Array.from(document.querySelectorAll('.property-row')).map(row => ({
    name: row.querySelector('[data-field="name"]').value.trim(),
    type: row.querySelector('[data-field="type"]').value,
    required: row.querySelector('[data-field="required"]').checked
  })).filter(p => p.name);

  // Gather relationships
  const relationships = Array.from(document.querySelectorAll('.relationship-row')).map(row => ({
    type: row.querySelector('[data-field="type"]').value.trim(),
    target_label: row.querySelector('[data-field="target_label"]').value,
    properties: []
  })).filter(r => r.type && r.target_label);

  const payload = { name, properties, relationships };

  fetch('/api/labels', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  })
    .then(r => r.json())
    .then(data => {
      if (data.status === 'success') {
        showToast('Label saved successfully', 'success');
        currentLabel = data.label;
        loadLabels();
        populateEditor(currentLabel);
        // Switch back to read-only mode after save
        isEditMode = false;
        updateEditorView();
      } else {
        showToast('Error saving label: ' + (data.error || 'Unknown error'), 'error');
      }
    })
    .catch(err => showToast('Network error: ' + err.message, 'error'));
}

function deleteLabel() {
  if (!currentLabel) return;

  if (!confirm(`Delete label "${currentLabel.name}"?`)) return;

  fetch(`/api/labels/${currentLabel.name}`, { method: 'DELETE' })
    .then(r => r.json())
    .then(data => {
      if (data.status === 'success') {
        showToast('Label deleted successfully', 'success');
        currentLabel = null;
        document.getElementById('label-editor').style.display = 'none';
        loadLabels();
      } else {
        showToast('Error deleting label: ' + (data.error || 'Unknown error'), 'error');
      }
    })
    .catch(err => showToast('Network error: ' + err.message, 'error'));
}

function pullFromNeo4j() {
  if (!currentLabel) return;

  if (!confirm(`Pull schema for "${currentLabel.name}" from Neo4j? This will add any missing properties and relationships from the Neo4j schema.`)) return;

  showToast('Pulling from Neo4j...', 'info');

  fetch(`/api/labels/${currentLabel.name}/pull`, { method: 'POST' })
    .then(r => r.json())
    .then(data => {
      if (data.status === 'success') {
        const propCount = data.new_properties_count || 0;
        const relCount = data.new_relationships_count || 0;
        const total = propCount + relCount;

        let msg = '';
        if (total === 0) {
          msg = 'No new schema found in Neo4j';
        } else {
          const parts = [];
          if (propCount > 0) parts.push(`${propCount} property${propCount > 1 ? 'ies' : ''}`);
          if (relCount > 0) parts.push(`${relCount} relationship${relCount > 1 ? 's' : ''}`);
          msg = `Added ${parts.join(' and ')} from Neo4j`;
        }

        showToast(msg, 'success');
        loadLabel(currentLabel.name);
      } else {
        showToast('Error pulling from Neo4j: ' + (data.error || 'Unknown error'), 'error');
      }
    })
    .catch(err => showToast('Network error: ' + err.message, 'error'));
}

function pullAllFromNeo4j() {
  if (!confirm('Pull all labels from Neo4j? This will import all labels and may overwrite local definitions.')) return;

  showToast('Pulling all labels from Neo4j...', 'info');

  fetch('/api/labels/pull', { method: 'POST' })
    .then(r => r.json())
    .then(data => {
      if (data.status === 'success') {
        showToast(`Imported ${data.count} labels from Neo4j`, 'success');
        loadLabels();
      } else {
        showToast('Error pulling from Neo4j: ' + (data.error || 'Unknown error'), 'error');
      }
    })
    .catch(err => showToast('Network error: ' + err.message, 'error'));
}

function previewArrowsImport() {
  const input = document.getElementById('arrows-json-input').value.trim();
  if (!input) {
    document.getElementById('import-preview').style.display = 'none';
    return;
  }

  try {
    const arrowsJson = JSON.parse(input);
    const nodeCount = arrowsJson.nodes?.length || 0;
    const relCount = arrowsJson.relationships?.length || 0;

    document.getElementById('preview-label-count').textContent = nodeCount;
    document.getElementById('preview-rel-count').textContent = relCount;
    document.getElementById('import-preview').style.display = 'block';
  } catch (e) {
    document.getElementById('import-preview').style.display = 'none';
  }
}

async function importFromArrows() {
  const input = document.getElementById('arrows-json-input').value.trim();
  if (!input) {
    showToast('Please paste Arrows.app JSON', 'warning');
    return;
  }

  try {
    const arrowsJson = JSON.parse(input);
    showToast('Importing schema...', 'info');

    const resp = await fetch('/api/labels/import/arrows', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({arrows_json: arrowsJson, mode: 'merge'})
    });

    const result = await resp.json();
    console.log('Import result:', result);

    if (result.status === 'success') {
      const msg = `Imported ${result.imported.labels} labels, ${result.imported.relationships} relationships`;
      showToast(msg, 'success');

      // Close modal
      closeImportModal();

      // Reload labels
      loadLabels();
    } else {
      showToast('Import failed: ' + result.error, 'error');
    }
  } catch (e) {
    console.error('Import error:', e);
    showToast('Import error: ' + e.message, 'error');
  }
}

async function exportToArrows() {
  try {
    showToast('Exporting schema...', 'info');
    window.location = '/api/labels/export/arrows';
    setTimeout(() => showToast('Schema exported successfully', 'success'), 500);
  } catch (e) {
    showToast('Export error: ' + e.message, 'error');
  }
}

// Batch operations
async function batchPull() {
  if (selectedLabels.size === 0) return;

  const labelNames = Array.from(selectedLabels);
  if (!confirm(`Pull schema for ${labelNames.length} selected labels from Neo4j?`)) return;

  showToast(`Pulling schema for ${labelNames.length} labels...`, 'info');

  try {
    const resp = await fetch('/api/labels/batch/pull', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ label_names: labelNames })
    });

    const result = await resp.json();

    if (result.status === 'success') {
      const totalProps = result.total_new_properties || 0;
      const totalRels = result.total_new_relationships || 0;
      const msg = `Batch pull complete: ${totalProps} properties, ${totalRels} relationships added`;
      showToast(msg, 'success');
      clearSelection();
      loadLabels();
    } else {
      showToast('Batch pull error: ' + (result.error || 'Unknown error'), 'error');
    }
  } catch (e) {
    showToast('Network error: ' + e.message, 'error');
  }
}

async function batchDelete() {
  if (selectedLabels.size === 0) return;

  const labelNames = Array.from(selectedLabels);
  if (!confirm(`Delete ${labelNames.length} selected labels?\n\n${labelNames.join(', ')}\n\nThis cannot be undone.`)) return;

  showToast(`Deleting ${labelNames.length} labels...`, 'info');

  try {
    const resp = await fetch('/api/labels/batch/delete', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ label_names: labelNames })
    });

    const result = await resp.json();

    if (result.status === 'success') {
      showToast(`Deleted ${result.deleted_count} labels`, 'success');
      clearSelection();
      currentLabel = null;
      document.getElementById('label-editor').style.display = 'none';
      document.getElementById('labels-statistics').style.display = 'none';
      loadLabels();
    } else {
      showToast('Batch delete error: ' + (result.error || 'Unknown error'), 'error');
    }
  } catch (e) {
    showToast('Network error: ' + e.message, 'error');
  }
}

function populateStatistics(label) {
  const container = document.getElementById('statistics-content');

  // Calculate statistics
  const propertyCount = label.properties.length;
  const requiredCount = label.properties.filter(p => p.required).length;
  const optionalCount = propertyCount - requiredCount;
  const outgoingRels = label.relationships.length;
  const incomingRels = (label.incoming_relationships || []).length;
  const totalRels = outgoingRels + incomingRels;

  // Property type distribution
  const typeDistribution = {};
  label.properties.forEach(prop => {
    typeDistribution[prop.type] = (typeDistribution[prop.type] || 0) + 1;
  });

  const typeDistHtml = Object.entries(typeDistribution).map(([type, count]) =>
    `<div class="small" style="margin-left: 1rem;">• ${type}: ${count}</div>`
  ).join('');

  // Relationship details
  const outgoingRelsHtml = label.relationships.map(rel =>
    `<div class="small" style="margin-left: 1rem;">• [${rel.type}] → ${rel.target_label}</div>`
  ).join('') || '<div class="small" style="margin-left: 1rem; color: #999;">None</div>';

  const incomingRelsHtml = (label.incoming_relationships || []).map(rel =>
    `<div class="small" style="margin-left: 1rem;">• ${rel.source_label} → [${rel.type}]</div>`
  ).join('') || '<div class="small" style="margin-left: 1rem; color: #999;">None</div>';

  container.innerHTML = `
    <div style="margin-bottom: 1.5rem;">
      <h4 class="small" style="font-weight: bold; margin-bottom: 0.5rem;">Properties</h4>
      <div class="small">Total: <strong>${propertyCount}</strong></div>
      <div class="small">Required: <strong>${requiredCount}</strong></div>
      <div class="small">Optional: <strong>${optionalCount}</strong></div>
      ${typeDistHtml ? '<div class="small" style="margin-top: 0.5rem; font-weight: bold;">Type Distribution:</div>' + typeDistHtml : ''}
    </div>

    <div style="margin-bottom: 1.5rem;">
      <h4 class="small" style="font-weight: bold; margin-bottom: 0.5rem;">Relationships</h4>
      <div class="small">Total: <strong>${totalRels}</strong></div>
      <div class="small">Outgoing: <strong>${outgoingRels}</strong></div>
      ${outgoingRelsHtml}
      <div class="small" style="margin-top: 0.5rem;">Incoming: <strong>${incomingRels}</strong></div>
      ${incomingRelsHtml}
    </div>

    <div style="margin-bottom: 1.5rem;">
      <h4 class="small" style="font-weight: bold; margin-bottom: 0.5rem;">Instances</h4>
      <div class="small" style="color: #999;">Instance count requires Neo4j connection</div>
      <div class="small" style="margin-top: 0.5rem;">
        <button class="btn btn-sm btn-outline-primary" onclick="loadInstanceCount('${label.name}')" style="font-size: 0.75rem;">
          Check Neo4j
        </button>
      </div>
      <div id="instance-count-${label.name}" style="margin-top: 0.5rem;"></div>
    </div>
  `;
}

async function loadInstanceCount(labelName) {
  const countDiv = document.getElementById(`instance-count-${labelName}`);
  countDiv.innerHTML = '<div class="small" style="color: #666;">Loading...</div>';

  try {
    const resp = await fetch(`/api/labels/${labelName}/instance-count`);
    const result = await resp.json();

    if (result.status === 'success') {
      const count = result.count || 0;
      countDiv.innerHTML = `<div class="small"><strong>${count}</strong> instance${count !== 1 ? 's' : ''} in Neo4j</div>`;
    } else {
      countDiv.innerHTML = `<div class="small" style="color: #b00020;">${result.error || 'Error loading count'}</div>`;
    }
  } catch (e) {
    countDiv.innerHTML = `<div class="small" style="color: #b00020;">Error: ${e.message}</div>`;
  }
}

// Instance browser functions
let instanceData = [];
let instancePage = 0;
let instanceLimit = 50;
let instanceChanges = {};

async function pullInstances() {
  if (!currentLabel) return;

  showToast('Pulling instances from Neo4j...', 'info');

  try {
    const resp = await fetch(`/api/labels/${currentLabel.name}/instances?limit=${instanceLimit}&offset=${instancePage * instanceLimit}`);
    const result = await resp.json();

    if (result.status === 'success') {
      instanceData = result.instances || [];
      instanceChanges = {};
      renderInstanceTable();
      showToast(`Loaded ${instanceData.length} instances`, 'success');
      document.getElementById('btn-push-instances').style.display = 'none';
    } else {
      showToast('Error loading instances: ' + (result.error || 'Unknown error'), 'error');
    }
  } catch (e) {
    showToast('Network error: ' + e.message, 'error');
  }
}

async function pushInstances() {
  showToast('Push instances feature coming soon', 'info');
}

async function refreshInstances() {
  instancePage = 0;
  await pullInstances();
}

function navigateInstances(delta) {
  instancePage = Math.max(0, instancePage + delta);
  pullInstances();
}

function renderInstanceTable() {
  const container = document.getElementById('instance-table-container');

  if (instanceData.length === 0) {
    container.innerHTML = '<div class="empty-state small">No instances found</div>';
    document.getElementById('instance-pagination').style.display = 'none';
    return;
  }

  // Get property names from current label
  const properties = currentLabel.properties.map(p => p.name);

  // Build table
  let html = '<table class="instance-table"><thead><tr>';
  html += '<th>ID</th>';
  properties.forEach(prop => {
    html += `<th>${prop}</th>`;
  });
  html += '</tr></thead><tbody>';

  instanceData.forEach(instance => {
    html += '<tr>';
    html += `<td style="font-family: monospace; font-size: 0.75rem;">${instance.id.substring(0, 8)}...</td>`;
    properties.forEach(prop => {
      const value = instance.properties[prop] || '';
      html += `<td><div class="instance-cell-editable" data-id="${instance.id}" data-prop="${prop}">${value}</div></td>`;
    });
    html += '</tr>';
  });

  html += '</tbody></table>';
  container.innerHTML = html;

  // Show pagination
  document.getElementById('instance-pagination').style.display = 'flex';
  document.getElementById('instance-page-info').textContent = `Page ${instancePage + 1} (${instanceData.length} instances)`;

  // TODO: Add cell editing logic in next phase
}
</script>
{% endblock %}
